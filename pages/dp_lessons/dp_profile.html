<!DOCTYPE html>
<html>
    <head>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-Y8NQ36XMJS"></script>
		<script>
		  window.dataLayer = window.dataLayer || [];
		  function gtag(){dataLayer.push(arguments);}
		  gtag('js', new Date());

		  gtag('config', 'G-Y8NQ36XMJS');
		</script>
        
        <link rel="shortcut icon" href="/algo-site/images/favicon.ico">
        <link type="text/css" rel="stylesheet" href="/algo-site/node_modules/bootstrap/dist/css/bootstrap.min.css"  media="screen,projection"/>
        <link type="text/css" rel="stylesheet" href="/algo-site/node_modules/@highlightjs/cdn-assets/styles/github-dark.min.css">
        <link type="text/css" rel="stylesheet" href="/algo-site/styles/style.css"  media="screen,projection"/>
        <link type="text/css" rel="stylesheet" href="/algo-site/styles/lesson.css"  media="screen,projection"/>
        <link type="text/css" rel="stylesheet" href="/algo-site/styles/dp_profile.css"  media="screen,projection"/>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
        <script type="text/javascript" src="/algo-site/node_modules/jquery/dist/jquery.slim.min.js"></script>
        <script type="text/javascript" src="/algo-site/node_modules/jquery/dist/jquery.min.js"></script>
        <script type="text/javascript" src="/algo-site/node_modules/@popperjs/core/dist/umd/popper.min.js"></script>
        <script type="text/javascript" src="/algo-site/node_modules/bootstrap/dist/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="/algo-site/node_modules/snapsvg/dist/snap.svg-min.js"></script>
        <script id="MathJax-script" async src="/algo-site/node_modules/mathjax/es5/tex-chtml.js"></script>
        <script type="text/javascript" src="/algo-site/node_modules/@highlightjs/cdn-assets/highlight.min.js"></script>
        <script type="text/javascript" src="/algo-site/js/main.js"></script>
        <script type="text/javascript" src="/algo-site/js/dp_lessons/dp_profile.js"></script>
        <title>Динамично по профил</title>
    </head>
    <body>
        <header>
            <div id="nav-placeholder"></div>
            <nav aria-label="breadcrumb" class="unselectable">
                <ol class="breadcrumb">
                    <li class="breadcrumb-item">
                        <a href="/algo-site/pages/dp_lessons.html" class="link-danger">Динамично програмиране</a>
                    </li>
                    <li class="breadcrumb-item active" aria-current="page">Динамично по профил</li>
                    <li class="ms-auto">Последна промяна: 11.08.2021</li>
                </ol>
            </nav>
        </header>
        
        <div class="wrapper" tabindex="-1">
            <div class="content">            
                <h1 align="center">Динамично по профил</h1>

                <div class="lesson-part-position">
                    <button class="btn btn-secondary">1. Какво представлява динамичното по профил?</button>
                    <div id="firstPart">
                        <p class="text-format">Това понятие обикновено се използва при динамични за някакъв тип броене в таблица \(n\)x\(m\), където едното измерение е малко, а другото е огромно (например от порядъка на \(10^9\) или даже \(10^{18}\). Нека за улеснение на обяснението и конкретика, приемем, че броят редове \(n\) е малък, а броят колони \(m\) е голям. Тогава трябва по подходящ начин да намерим подробно и еднотипно описание на колоната, което ще наричаме профил на колоната (по принцип то не трябва да зависи от конкретния номер на колоната). Понеже броят редове е малък в една колона, то различните профили на колоната трябва да са достатъчно малко, за да приложим техниката динамично по профил. Динамичното се състои в това, че приемаме, че сме намерили цялата информация до \(i-\)та колона, това включва и подробна информация за всеки възможен профил на тази колона. След което искаме да намерим същата информация за \((i+1)-\)ва колона. Същността на техниката е, като имаме подходящ профил, да намерим как преминаваме от един профил до друг (дали можем, по колко начина и т.н.) и така да направим този преход от \(i-\)та в \((i+1)-\)ва колона "автоматизирано" чрез умножение с матрица. По този начин намирането на целия отговор за таблицата с \(m\) колони ще става с повдигане на матрица в степен.</p>
                    </div>
                </div>

                <div class="lesson-part-position">
                    <button class="btn btn-secondary">2. Получаване на матрицата на прехода</button>
                    <div id="secondPart">
                        <p class="text-format">Ще разгледаме една лесна задача, с която ще покажем нагледно техниката. Нека имаме таблица \(n\)x\(m\), която искаме да оцветим в черно и бяло, така че да няма две съседни (по страна) черни клетки. Търсим по колко начина може да стане това. Нека фиксираме конкретни стойности: \(n=m=2\). Тогава имаме следните 7 възможности:</p>
                        <div class="row justify-content-center" style="margin-top: -2%">
                            <table class="table">
                                <tbody>
                                    <tr><td class="white"></td><td class="white"></td></tr>
                                    <tr><td class="white"></td><td class="white"></td></tr>
                                </tbody>
                            </table>
                            <table class="table">
                                <tbody>
                                    <tr><td class="white"></td><td class="white"></td></tr>
                                    <tr><td class="black"></td><td class="white"></td></tr>
                                </tbody>
                            </table>
                            <table class="table">
                                <tbody>
                                    <tr><td class="black"></td><td class="white"></td></tr>
                                    <tr><td class="white"></td><td class="white"></td></tr>
                                </tbody>
                            </table>
                            <table class="table">
                                <tbody>
                                    <tr><td class="white"></td><td class="black"></td></tr>
                                    <tr><td class="white"></td><td class="white"></td></tr>
                                </tbody>
                            </table>
                            <table class="table">
                                <tbody>
                                    <tr><td class="white"></td><td class="black"></td></tr>
                                    <tr><td class="black"></td><td class="white"></td></tr>
                                </tbody>
                            </table>
                            <table class="table">
                                <tbody>
                                    <tr><td class="white"></td><td class="white"></td></tr>
                                    <tr><td class="white"></td><td class="black"></td></tr>
                                </tbody>
                            </table>
                            <table class="table">
                                <tbody>
                                    <tr><td class="black"></td><td class="white"></td></tr>
                                    <tr><td class="white"></td><td class="black"></td></tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="text-format">За да подходим в стила на динамичното програмиране, идеята ще е да намерим броя начини за оцветяване на първите \(i+1\) колони, след като вече знаем броя начини за първите \(i\) колони. В общия случай няма как директно да го направим. Затова трябва да намерим необходимата информация, която да ни позволи това. В тази задача профилът е ясен - за всяка колона е достатъчно да знаем кои клетки сме оцветили в бяло и кои в черно, т.е. профилът е просто битова маска на оцветяването на дадена колона. Тази информация е еднотипна за всяка колона. Очевидно като знаем оцветяването на последната колона, знаем какви са валидните възможности за оцветяването на следващата колона. Това показва, че избраният профил е подходящ за задачата - можем да минаваме от един профил към друг. Всъщност така направихме първата стъпка за тази техника - да намерим подходящ профил. Един профил е подходящ, ако в него се включват всички възможности и може да се минава от един профил в друг без значение за кой номер на колона става дума. След като намерим подходящ профил намираме валидните профили и ги номерираме. За да е валиден даден профил, не трябва да има две съседни черни клетки в него. При два реда имаме три валидни профила от общо 4 възможни:
                        <div class="row justify-content-center" style="margin-top: -2%">
                            <table class="table table-borderless profile">
                                <thead><tr><th class="text-center">0</th></tr></thead>
                                <tbody>
                                    <tr><td class="white"></td></tr>
                                    <tr><td class="white"></td></tr>
                                </tbody>
                            </table>
                            <table class="table table-borderless profile">
                                <thead><tr><th class="text-center">1</th></tr></thead>
                                <tbody>
                                    <tr><td class="black"></td></tr>
                                    <tr><td class="white"></td></tr>
                                </tbody>
                            </table>
                            <table class="table table-borderless profile">
                                <thead><tr><th class="text-center">2</th></tr></thead>
                                <tbody>
                                    <tr><td class="white"></td></tr>
                                    <tr><td class="black"></td></tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="text-format">Стейтът на динамичното е \(dp[\)брой колони\(][\)номер на профила на последната колона\(]\), като в него пазим броя валидни оцветявания. Базовите стойности са: \(dp[1][0]=dp[1][1]=dp[1][2]=1\) (<a class="info">...</a><a class="info" style="display: none">понякога не всички профили са валидни за начални</a>). За да сметнем стойностите при две колони е достатъчно да видим кои профили са съвместими. Написано подробно:<p>
                        <ul>
                            <li class="dashed-list">\(dp[2][0]=1*dp[1][0]+\) \(1*dp[1][1]+1*dp[1][2]=3\)</li>
                            <li class="dashed-list">\(dp[2][1]=1*dp[1][0]+\) \(0*dp[1][1]+1*dp[1][2]=2\)</li>
                            <li class="dashed-list">\(dp[2][2]=1*dp[1][0]+\) \(1*dp[1][1]+0*dp[1][2]=2\)</li>
                        </ul>
                        <p class="text-format">Всъщност едниствените несъвместими профили като ляв и десен са номер 1 със себе си и номер 2 със себе си. Може да се провери, че тези числа съответстват на разписването в случая \(2\)x\(2\) по-горе. От друга страна горните формули са същите за получаване на бройките при 3 колони от тези за 2, при 4 колони от тези за 3 и т.н. Така в общия случай за \(m\) колони при два реда е вярно:</p>
                        <ul>
                            <li class="dashed-list">\(dp[m][0]=1*dp[m-1][0]+\) \(1*dp[m-1][1]+1*dp[m-1][2]\)</li>
                            <li class="dashed-list">\(dp[m][1]=1*dp[m-1][0]+\) \(0*dp[m-1][1]+1*dp[m-1][2]\)</li>
                            <li class="dashed-list">\(dp[m][2]=1*dp[m-1][0]+\) \(1*dp[m-1][1]+0*dp[m-1][2]\)</li>
                        </ul>
                        <p class="text-format">Тази сметка може да се изрази и чрез матрично умножениe по следния начин: \(\begin{pmatrix}dp[m-1][0] & dp[m-1][1] & dp[m-1][2]\end{pmatrix}*T=\) \(\begin{pmatrix}dp[m][0] & dp[m][1] & dp[m][2]\end{pmatrix}\), където \(T\) се нарича матрица на прехода между профилите. В нашия случай при два реда - \(T=\begin{pmatrix}1 & 1 & 1 \\ 1 & 0 & 1 \\ 1 & 1 & 0\end{pmatrix}\). Всъщност числата в колоните с индекси 0, 1 и 2 са коефициентите при смятането на \(dp[m][0], dp[m][1]\) и \(dp[m][2]\).</p>
                        <p class="text-format">Забележете, че матрицата на прехода зависи от броя редове в задачата. Горна оценка за големината на \(T\) е \(2^n\) x \(2^n\). При малко по-точен анализ, лесно може да се забележи, че броят валидни профили в зависимост от броя редове образуват редицата на Фибоначи или при \(n\) реда, броят е \(F_{n+2}\). Като вземем предвид, че \(F_{n} \approx \varphi^n\), то големината на \(T\) пак е експоненциална спрямо \(n\): \(\varphi^{n+2}\) x \(\varphi^{n+2}\) (<a class="info">...</a><a class="info" style="display: none">известно още и като златното сечение - \(\varphi \approx 1.618\)</a>). Затова искаме малък брой на редовете, иначе този подход е неприложим.</p>
                        <div class="row">
                            <div class="col-sm-10">
                                <p class="text-format">Вече разглеждаме задачата в общия случай. Както казахме, първо намираме матрицата на прехода. За тази цел в началото намираме валидните профили и ги номерираме с числата \(0, 1, ..., k-1\). За да намерим самата матрица, трябва да намерим за всеки два профила дали са съвместими (в някои случаи, при по-обобщен профил, тук може и да смятаме по колко начина са съвместими). Два профила \(l\) и \(r\) са несъвместими тогава и само тогава когато имат на един и същ ред черна клетка. Ако разглеждаме битовите маски на профилите това означава, че трябва да проверяваме дали имат бит 1 на една и съща позиция.</p>
                            </div>
                            <div class="col-sm-2 d-flex justify-content-center">
                                <div style="display: flex; align-items: center">
                                    <table class="table transition">
                                        <tbody>
                                            <tr><td class="white text-center align-middle unselectable">\(l\)</td>
                                                <td class="white text-center align-middle unselectable">\(r\)</td></tr>
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                        <p class="text-format">Следният код намира профилите и матрицата на прехода \(T\):</p>
                        <div id="find-transition-matrix" class="placeholder"></div>
                    </div>
                </div>

                <div class="lesson-part-position">
                    <button class="btn btn-secondary">3. Свеждане до бързо повдигане на матрица в степен</button>
                    <div id="thirdPart">
                        <p class="text-format">Нека означим матрицата с началните стойности с \(B\), т.е. \(B=\begin{pmatrix}dp[1][0] & dp[1][1] & ... & dp[1][k-1]\end{pmatrix}\)\(=\begin{pmatrix}1 & 1 & ... & 1\end{pmatrix}\), защото в нашата задача всички профили са възможни за начални. Вече обосновахме, че за да смятаме стойностите, като добавим още една колона, е достатъчно да умножим с матрицата на прехода \(T\). Това означава, че за да стигнем до \(m\) колони, трябва да сметнем \(B*\underbrace{T*T*...*T}_\text{\(m-1\) на брой}\). Без да ползваме техниката динамично по профил тази задача бихме я решили, като последователно смятахме динамичните за 1 колона, 2 колони и т.н., което съответства на следното смятане с матрици: \(B*T, (B*T)*T, ...\). Ако смятаме по този начин, сложността ще е \(O(m*2^{2n})\), което е неприложимо за големи \(m\). Но матричното умножение е асоциативно, което означава, че \(B*\underbrace{T*T*...*T}_\text{\(m-1\) на брой}=\)\(B*(T*T*...*T)=B*T^{m-1}\). Така първо ще сметнем \(T^{m-1}\). Разбира се, ако го правим по наивния начин ще получим ужасна сложност \(O(m*2^{3n})\), но можем да се възползваме от бързото повдигане в степен и така да паднем до \(O(\log{m}*2^{3n})\). Нека означим \(T^{m-1}=R\). След като сме сметнали \(R\), остава лявото умножение с \(B\), за да получим \(\begin{pmatrix}dp[m][0] & dp[m][1] & ... & dp[m][k-1]\end{pmatrix}\), но понеже имаме само единици за базови стойности, то \(dp[m][p]=\sum\limits_{i=0}^{k-1} R[i][p]\). Всъщност отговорът на задачата е \(\sum\limits_{p=0}^{k-1} dp[m][p]\) или се получава сумата на числата в матрицата \(R\) - \(\sum\limits_{b=0}^{k-1} \sum\limits_{e=0}^{k-1} R[b][e]\).</p>
                        <p class="text-format">Този резултат можехме да получим и по друг начин, който е по-ценен за осмислянето на умножението на матриците на прехода. Можем да кажем, че всъщност \(T[l][r]\) е броят валидни оцветяване на 2 колони, при които първата е с профил \(l\), а втората е с профил \(r\). Това означава, че от своя страна \(T^2[l][r]\) ще е броят валидни оцветяване на 3 колони, при които първата е в профил \(l\), а последната е с профил \(r\). Така ако погледнем \(T^{m-1}\), номерът на реда съответства на профил на първата колона, а номерът на стълба - на профил на последна колона. Затова при произволна задача, за да намерим крайният отговор е достатъчно да съберем числата на редовете с валиден профил за начален и колоните с валиден профил за краен! В разглежданата задача всички профили са валидни за начални и крайни, затова и се получава, че събираме всичките числа в \(T^{m-1}=R\). Предоставяме код, където при вече намерена матрица на прехода, намираме и броят валидни оцветявания на таблица \(n\)x\(m\).</p>
                        <div id="find-answer" class="placeholder"></div>
                        <p class="text-format">В следващия интерактивен пример могат да се въвеждат различни стойности за размерите на таблицата и да се пресмятат матриците \(T\) и \(T^{m-1}\). Също така се показват номерираните профили в реда, в който са и матриците, както и крайният отговор за съответните размери на таблицата. Максималната позволена стойност за \(n\) e 3. Всички сметки се извършват по модул 100!</p>
                        <div class="dpProfileExample1">
                            <div class="row">
                                <div class="col-md-3 col-lg-2">
                                    <div class="row justify-content-end mb-3">
                                        <label for="n" class="col-auto col-form-label pe-0">\(n\):</label>
                                        <div class="col-auto">
                                            <input class="form-control n" maxLength="1" style="width: 2.5rem; max-width: 100%"/>
                                        </div>
                                    </div>
                                    <div class="row justify-content-end mb-3">
                                        <label for="n" class="col-auto col-form-label pe-0">\(m\):</label>
                                        <div class="col-auto">
                                            <input class="form-control m" maxLength="2" style="width: 3rem; max-width: 100%"/>
                                        </div>
                                    </div>
                                    <div class="row justify-content-end">
                                        <div class="col-auto mb-2">
                                            <button class="btn btn-primary calc">Сметни!</button>
                                        </div>
                                        <p class="answer" style="text-align: right; font-weight: bold"></p>
                                    </div>
                                </div>
                                <div class="col-md-9 col-lg-10">
                                    <div class="row justify-content-center profiles" style="margin-bottom: 2%"></div>
                                    <div class="row">
                                        <div class="col-sm-5 text-center">
                                            <p class="T"></p>
                                        </div>
                                        <div class="col-sm-7 text-center">
                                            <p class="Tm"></p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <p class="text-format">Последно ще кажем, че не винаги този подход при динамичното по профил е най-удачен, нещата зависят от конкретните ограничения. Ако няма малко измерение, то \(O(2^{3n})\) или най-общо казано сложността за извършване на умножението на матрици при намиране на \(T^2\), може да е твърде голяма. Тогава ако все пак няма много голямо измерение на таблицата, най-подходящо е стандартното намиране на динамичното, което вече описахме (със сложност \(O(m*2^{2n})\) за нашата задача). Въпреки това част от подходите са добри практики - намирането на валидните профили, както и за всеки профил с кои и по колко начина е съвместим. Така стандартният начин се забързва малко повече.</p>
                    </div>
                </div>

                <div class="lesson-part-position">
                    <button class="btn btn-secondary">4. Задачата за покритието с домина</button>
                    <div id="fourthPart">
                        <p class="text-format">Една доста известна задача е за броя начини да се покрие таблица \(n\)x\(m\) с домина (<a class="info">...</a><a class="info" style="display: none">правоъгълни плочки с размери 1х2</a>). БОО (<a class="info">...</a><a class="info" style="display: none">без ограничение на общността</a>) \(n \le m\). Тази задача има разнообразни решения. Стандартното решение с динамично с маска на последния стълб е със сложност \(O(m*2^{2n})\). То обаче е по-бавно, а може би и по-тежко за писане, от решението с плъзгаща се битова маска, което има сложност \(O(nm*2^n)\) (<a class="info">...</a><a class="info" style="display: none">може да разгледатe това решение в темата за динамично по подмножества</a>). Сега ще разгледаме решение в стила на динамично по профил, което ще е със сложност \(O(\log{m}*2^{3n})\). То ще е удачното, когато броя редове е малък до 6-7, иначе най-доброто би било динамичното с плъзгаща се битова маска.</p>
                        <p class="text-format">Има различни начини за съставяне на профил. Най-лесният е да въведем три състояния за всяка клетка в колоната - покрита от вертикално домино, покрита от хоризонтално домино от предната колона или покрита от хоризонтално домино, отиващо в следващата колона. То обаче не е най-оптималното и ще доведе до много профили. По-оптимални варианти са следните. Един вариант е да оставяме празни клетки в колоната, които да бъдат попълнени при добавяне на следващата колона, а друг е да слагаме хоризонтални домина, които да "стърчат" от последната колона. Ще разгледаме втората възможност. Както в предната задача, ще използваме битова маска за кодиране на конфигурациите. Бит със стойност 1 ще означава, че сме поставили хоризонтално домино в тази клетка, което стърчи към следващата колона. Ако стойността е 0, това ще означава, че клетката е покрита с вертикално домино или хоризонтално, което започва от предишната колона. На пръв поглед може да изглежда, че този профил не винаги е еднозначен - когато имаме 0, не е напълно ясно дали клетката е покрита с вертикално или хоризонтално домино. Обаче ако разгледаме комбиниране на профили на лява и дясна колона, то при дясната колона нулите стават еднозначни - ако са покрити с хоризонтално домино от предишната колона, то при лявата колона, на съответното място, трябва да имаме бит 1 (за стърчащо домино), иначе са покрити с вертикално домино. За да стане по-ясна тази концепция е предоставен интерактивен пример, където могат да се въвеждат битови маски на профилите на лява и дясна колона и да се види нагледно как се покрива дясната колона, ако са съвместими профилите. Редовете са най-много 5.</p>
                        <div class="dpProfileExample2">
                            <div class="row">
                                <div class="col-sm">
                                    <div class="row justify-content-end mb-3">
                                        <label for="l" class="col-auto col-form-label pe-0">\(l\):</label>
                                        <div class="col-auto">
                                            <input class="form-control l" maxLength="5" style="width: 4.5rem; max-width: 100%"/>
                                        </div>
                                    </div>
                                    <div class="row justify-content-end mb-3">
                                        <label for="r" class="col-auto col-form-label pe-0">\(r\):</label>
                                        <div class="col-auto">
                                            <input class="form-control r" maxLength="5" style="width: 4.5rem; max-width: 100%"/>
                                        </div>
                                    </div>
                                    <div class="row justify-content-end">
                                        <div class="col-auto">
                                            <button class="btn btn-primary check">Провери!</button>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-sm">
                                    <div class="row justify-content-center profiles-check" style="height: 100%; align-items: center">
                                        <p class="error"></p>
                                        <table class="table profiles" style="border: none"></table>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <p class="text-format">Оказва се, че всички профили са валидни. Сега да изясним кога два профила са съвместими. Първото условие е на всеки бит 1 в левия профил да съответства бит 0 в десния профил, защото този бит е означавал стърчащо домино от лявата колона и то трябва да завършва на това място в десния профил. Останалите битове в левия профил са нули и съответните клетки трябва вече да са коректно покрити (без значение десния профил), така че при тях няма допълнителни условия. За десния профил знаем, че битовете 1 означават стърчащи домина, освен това част от нулите (съседни на бит 1 в левия профил) са покрити от хоризонтални домина, почващи в лявата колона. Всички останали нулеви битове трябва да са за вертикални домина! Така че второто условие е точно това - групите нули в десния профил, оградени от хоризонтални домина, да са четен брой, за да могат да се покрият с вертикални. Ето код, който намира матрицата на прехода \(T\) за този профил:</p>
                        <div id="transition-matrix-dominos" class="placeholder"></div>
                        <p class="text-format">Тук не всички профили са валидни за начални. Единствените хоризонтални домина в първата колона са стърчащи, което означава, че всички нули са покрити само от вертикални домина. Така че валидни начални профили са тези, при които всички поредици от нули са с четна големина. От друга страна в последната колона, хоризонталните домина трябва да започват от предходната колона. Това означава, че само профилът с маска 0 е валиден за краен. Като имаме матрицата на прехода, трябва да направим бързото повдигане в степен, което показахме, и да намерим \(T^{m-1}\). За крайният отговор трябва да съберем числата от първата колона (тази с индекс 0, съответстваща на профил 0) на редовете с валиден начален профил.</p>
                    </div>
                </div>

            </div>
            
            <div id="footer-placeholder"></div>
        </div>
    </body>
</html>