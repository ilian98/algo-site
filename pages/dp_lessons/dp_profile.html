<!DOCTYPE html>
<html>
    <head>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-Y8NQ36XMJS"></script>
		<script>
		  window.dataLayer = window.dataLayer || [];
		  function gtag(){dataLayer.push(arguments);}
		  gtag('js', new Date());

		  gtag('config', 'G-Y8NQ36XMJS');
		</script>
        
        <link rel="shortcut icon" href="/algo-site/images/favicon.ico">
        <link type="text/css" rel="stylesheet" href="/algo-site/libs/bootstrap/dist/css/bootstrap.min.css"  media="screen,projection"/>
        <link type="text/css" rel="stylesheet" href="/algo-site/libs/highlight/styles/github-dark.min.css">
        <link type="text/css" rel="stylesheet" href="/algo-site/styles/style.css"  media="screen,projection"/>
        <link type="text/css" rel="stylesheet" href="/algo-site/styles/lesson.css"  media="screen,projection"/>
        <link type="text/css" rel="stylesheet" href="/algo-site/styles/dp_profile.css"  media="screen,projection"/>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
        <script type="text/javascript" src="/algo-site/libs/jquery/dist/jquery.slim.min.js"></script>
        <script type="text/javascript" src="/algo-site/libs/jquery/dist/jquery.min.js"></script>
        <script type="text/javascript" src="/algo-site/libs/popper.js/dist/umd/popper.min.js"></script>
        <script type="text/javascript" src="/algo-site/libs/bootstrap/dist/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="/algo-site/libs/Snap.svg/dist/snap.svg-min.js"></script>
        <script id="MathJax-script" async src="/algo-site/libs/mathjax/es5/tex-chtml.js"></script>
        <script type="text/javascript" src="/algo-site/libs/highlight/highlight.min.js"></script>
        <script type="text/javascript" src="/algo-site/js/main.js"></script>
        <script type="text/javascript" src="/algo-site/js/dp_lessons/dp_profile.js"></script>
        <title>Динамично по профил</title>
    </head>
    <body>
        <header>
            <div class="background"></div>
            <div id="nav-placeholder"></div>
            <nav aria-label="breadcrumb" class="unselectable">
                <ol class="breadcrumb">
                    <li class="breadcrumb-item" style="z-index:0">
                        <a href="/algo-site/pages/dp_lessons.html" class="text-danger">Динамично програмиране</a>
                    </li>
                    <li class="breadcrumb-item active" style="z-index:0" aria-current="page">Динамично по профил</li>
                    <li class="ml-auto">Последна промяна: 10.08.2021</li>
                </ol>
            </nav>
        </header>
        
        <div class="wrapper">
            <div class="content">            
                <h1 align="center">Динамично по профил</h1>

                <div class="lesson-part-position">
                    <button class="btn btn-secondary">1. Какво представлява динамичното по профил?</button>
                    <div id="firstPart">
                        <p class="text-format">Това понятие обикновено се използва при динамични за някакъв тип броене в таблица \(n\)x\(m\), където едното измерение е малко, а другото е огромно (например от порядъка на \(10^9\) или даже \(10^{18}\). Нека за улеснение на обяснението и конкретика, приемем, че броят редове \(n\) е малък, а броят колони \(m\) е голям. Тогава трябва по подходящ начин да намерим подробно и еднотипно описание на колоната, което ще наричаме профил на колоната (по принцип то не трябва да зависи от конкретния номер на колоната). Понеже броят редове е малък в една колона, то различните профили на колоната трябва да са достатъчно малко, за да приложим техниката динамично по профил. Динамичното се състои в това, че приемаме, че сме намерили цялата информация до \(i-\)та колона, това включва и подробна информация за всеки възможен профил на тази колона. След което искаме да намерим същата информация за \((i+1)-\)ва колона. Същността на техниката е, като имаме подходящ профил, да намерим как преминаваме от един профил до друг (дали можем, по колко начина и т.н.) и така да направим този преход от \(i-\)та в \((i+1)-\)ва колона "автоматизирано" чрез умножение с матрица. По този начин намирането на целия отговор за таблицата с \(m\) колони ще става с повдигане на матрица в степен.</p>
                    </div>
                </div>

                <div class="lesson-part-position">
                    <button class="btn btn-secondary">2. Получаване на матрицата на преходите</button>
                    <div id="secondPart">
                        <p class="text-format">Ще разгледаме една лесна задача, с която ще покажем нагледно техниката. Нека имаме таблица \(n\)x\(m\), която искаме да оцветим в черно и бяло, така че да няма две съседни (по страна) черни клетки. Търсим по колко начина може да стане това. Нека фиксираме конкретни стойности: \(n=m=2\). Тогава имаме следните 7 възможности:</p>
                        <div class="row justify-content-center" style="margin-top: -2%">
                            <table class="table">
                                <tbody>
                                    <tr><td class="white"></td><td class="white"></td></tr>
                                    <tr><td class="white"></td><td class="white"></td></tr>
                                </tbody>
                            </table>
                            <table class="table">
                                <tbody>
                                    <tr><td class="white"></td><td class="white"></td></tr>
                                    <tr><td class="black"></td><td class="white"></td></tr>
                                </tbody>
                            </table>
                            <table class="table">
                                <tbody>
                                    <tr><td class="black"></td><td class="white"></td></tr>
                                    <tr><td class="white"></td><td class="white"></td></tr>
                                </tbody>
                            </table>
                            <table class="table">
                                <tbody>
                                    <tr><td class="white"></td><td class="white"></td></tr>
                                    <tr><td class="white"></td><td class="black"></td></tr>
                                </tbody>
                            </table>
                            <table class="table">
                                <tbody>
                                    <tr><td class="black"></td><td class="white"></td></tr>
                                    <tr><td class="white"></td><td class="black"></td></tr>
                                </tbody>
                            </table>
                            <table class="table">
                                <tbody>
                                    <tr><td class="white"></td><td class="black"></td></tr>
                                    <tr><td class="white"></td><td class="white"></td></tr>
                                </tbody>
                            </table>
                            <table class="table">
                                <tbody>
                                    <tr><td class="white"></td><td class="black"></td></tr>
                                    <tr><td class="black"></td><td class="white"></td></tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="text-format">За да подходим в стила на динамичното програмиране, идеята ще е да намерим броя начини за оцветяване на първите \(i+1\) колони, след като вече знаем броя начини за първите \(i\) колони. В общия случай няма как директно да го направим. Затова трябва да намерим необходимата информация, която да ни позволи това. В тази задача профилът е ясен - за всяка колона е достатъчно да знаем кои клетки сме оцветили в бяло и кои в черно, т.е. профилът е просто битова маска на оцветяването на дадена колона. Тази информация е еднотипна за всяка колона. Очевидно като знаем оцветяването на последната колона, знаем какви са валидните възможности за оцветяването на следващата колона. Това показва, че избраният профил е подходящ за задачата - можем да минаваме от един профил към друг. Всъщност така направихме първата стъпка за тази техника - да намерим подходящ профил. Един профил е подходящ, ако в него се включват всички възможности и може да се минава от един профил в друг без значение за кой номер на колона става дума. След като намерим подходящ профил намираме валидните профили при два реда, които са три на брой и ги номерираме:
                        <div class="row justify-content-center" style="margin-top: -2%">
                            <table class="table table-borderless profile">
                                <thead><tr><th class="text-center">0</th></tr></thead>
                                <tbody>
                                    <tr><td class="white"></td></tr>
                                    <tr><td class="white"></td></tr>
                                </tbody>
                            </table>
                            <table class="table table-borderless profile">
                                <thead><tr><th class="text-center">1</th></tr></thead>
                                <tbody>
                                    <tr><td class="white"></td></tr>
                                    <tr><td class="black"></td></tr>
                                </tbody>
                            </table>
                            <table class="table table-borderless profile">
                                <thead><tr><th class="text-center">2</th></tr></thead>
                                <tbody>
                                    <tr><td class="black"></td></tr>
                                    <tr><td class="white"></td></tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="text-format">Стейтът на динамичното е \(dp[\)брой колони\(][\)профил на последната колона\(]\), като в него пазим броя валидни оцветявания. Базовите стойности са: \(dp[1][0]=dp[1][1]=dp[1][2]=1\) (<a class="info">...</a><a class="info" style="display: none">понякога не всички профили са валидни за начални</a>). За да сметнем стойностите при две колони е достатъчно да видим кои профили са съвместими. Написано подробно:<p>
                        <ul>
                            <li class="dashed-list">\(dp[2][0]=1*dp[1][0]+\) \(1*dp[1][1]+1*dp[1][2]=3\)</li>
                            <li class="dashed-list">\(dp[2][1]=1*dp[1][0]+\) \(0*dp[1][1]+1*dp[1][2]=2\)</li>
                            <li class="dashed-list">\(dp[2][0]=1*dp[1][0]+\) \(1*dp[1][1]+0*dp[1][2]=2\)</li>
                        </ul>
                        <p class="text-format">Всъщност едниствените несъвместими профили като ляв и десен са номер 1 със себе си и номер 2 със себе си. Може да се провери, че тези числа съответстват на разписването в случая \(2\)x\(2\) по-горе. От друга страна горните формули са същите за получаване на бройките при 3 колони от тези за 2, при 4 колони от тези за 3 и т.н. Така в общия случай за \(m\) колони при два реда е вярно:</p>
                        <ul>
                            <li class="dashed-list">\(dp[m][0]=1*dp[m-1][0]+\) \(1*dp[m-1][1]+1*dp[m-1][2]\)</li>
                            <li class="dashed-list">\(dp[m][1]=1*dp[m-1][0]+\) \(0*dp[m-1][1]+1*dp[m-1][2]\)</li>
                            <li class="dashed-list">\(dp[m][0]=1*dp[m-1][0]+\) \(1*dp[m-1][1]+0*dp[m-1][2]\)</li>
                        </ul>
                        <p class="text-format">Тази сметка може да се изрази и чрез матрично умножениe по следния начин: \(\begin{pmatrix}dp[m-1][0] & dp[m-1][1] & dp[m-1][2]\end{pmatrix}*T=\) \(\begin{pmatrix}dp[m][0] & dp[m][1] & dp[m][2]\end{pmatrix}\), където \(T\) се нарича матрица на прехода между профилите. В нашия случай при два реда - \(T=\begin{pmatrix}1 & 1 & 1 \\ 1 & 0 & 1 \\ 1 & 1 & 0\end{pmatrix}\).</p>
                        <p class="text-format">Забележете, че матрицата на прехода зависи от броя редове в задачата. Горна оценка за големината на \(T\) е \(2^n\) x \(2^n\). При малко по-точен анализ, лесно може да се забележи, че броят валидни профили в зависимост от броя редове образуват редицата на Фибоначи или при \(n\) реда, броят е \(F_{n+2}\). Като вземем предвид, че \(F_{n} \approx \varphi^n\), то големината на \(T\) пак е експоненциална спрямо \(n\): \(\varphi^{n+2}\) x \(\varphi^{n+2}\) (<a class="info">...</a><a class="info" style="display: none">известно още и като златното сечение - \(\varphi \approx 1.618\)</a>). Затова искаме малък брой на редовете, иначе този подход е неприложим.</p>
                        <div class="row">
                            <div class="col-sm-10">
                                <p class="text-format">Вече разглеждаме задачата в общия случай. Както казахме, първо намираме матрицата на преходите. За тази цел в началото намираме валидните профили и ги номерираме с числата \(0, 1, ..., k-1\). За да намерим самата матрица трябва да намерим за всеки два профила или не дали са съвместими (в някои случаи при по-обобщен профил, тук може и да смятаме по колко начина са съвместими). Два профила \(l\) и \(r\) са несъвместими тогава и само тогава когато имат на един и същ ред черна клетка. Ако разглеждаме битовите маски на профилите това означава, че трябва да проверяваме дали имат бит 1 на една и съща позиция.</p>
                            </div>
                            <div class="col-sm-2 d-flex justify-content-center">
                                <div style="display: flex; align-items: center">
                                    <table class="table transition">
                                        <tbody>
                                            <tr><td class="white text-center align-middle unselectable">\(l\)</td>
                                                <td class="white text-center align-middle unselectable">\(r\)</td></tr>
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                        <p class="text-format">Следният код намира профилите и матрицата на преходите \(T\):</p>
                        <div id="find-transition-matrix-placeholder"></div>
                    </div>
                </div>

                <div class="lesson-part-position">
                    <button class="btn btn-secondary">3. Свеждане до бързо повдигане на матрица в степен</button>
                    <div id="thirdPart">
                        <p class="text-format">Нека означим матрицата с началните стойности с \(B\), т.е. \(B=\begin{pmatrix}dp[1][0] & dp[1][1] & ... & dp[1][k-1]\end{pmatrix}\)\(=\begin{pmatrix}1 & 1 & ... & 1\end{pmatrix}\), защото в нашата задача всички профили са възможни за начални. Вече обосновахме, че за да смятаме стойностите като добавим още една колона, е достатъчно да умножим с матрицата на преходите \(T\). Това означава, че за да стигнем до \(m\) колони, трябва да сметнем \(B*\underbrace{T*T*...*T}_\text{\(m-1\) на брой}\). Без да ползваме техниката динамично по профил тази задача бихме я решили, като последователно смятахме динамичните за 1 колона, 2 колони и т.н., което съответства на следното смятане с матрици: \(B*T, (B*T)*T, ...\). Ако смятаме по този начин, сложността ще е \(O(m*2^{2n})\), което е неприложимо за големи \(m\). Но матричното умножение е асоциативно, което означава, че \(B*\underbrace{T*T*...*T}_\text{\(m-1\) на брой}=\)\(B*(T*T*...*T)=B*T^{m-1}\). Така първо ще сметнем \(T^{m-1}\). Разбира се, ако го правим по наивния начин ще получим ужасна сложност \(O(m*2^{3n})\), но можем да се възползваме от бързото повдигане в степен и така да паднем до \(O(\log{m}*2^{3n})\). Нека означим \(T^{m-1}=R\). След като сме сметнали \(R\), остава лявото умножение с \(B\), за да получим \(\begin{pmatrix}dp[m][0] & dp[m][1] & ... & dp[m][k-1]\end{pmatrix}\), но понеже имаме само единици за базови стойности, то \(dp[m][p]=\sum\limits_{i=0}^{k-1} R[i][p]\). Всъщност отговорът на задачата е \(\sum\limits_{p=0}^{k-1} dp[m][p]\) или се получава сумата на числата в матрицата \(R\) - \(\sum\limits_{b=0}^{k-1} \sum\limits_{e=0}^{k-1} R[b][e]\).</p>
                        <p class="text-format">Този резултат можехме да получим и по друг начин, който е по-ценен за осмислянето на умножението на матриците на прехода. Можем да кажем, че всъщност \(T[l][r]\) е броят валидни оцветяване на 2 колони, при които първата е с профил \(l\), а втората е с профил \(r\). Това означава, че от своя страна \(T^2[l][r]\) ще е броят валидни оцветяване на 3 колони, при които първата е в профил \(l\), а последната е с профил \(r\). Така ако погледнем \(T^{m-1}\), номерът на реда съответства на профил на първата колона, а номерът на стълба - на профил на последна колона. Затова при произволна задача, за да намерим крайният отговор е достатъчно да съберем числата на редовете с валиден профил за начален и колоните с валиден профил за краен! В разглежданата задача всички профили са валидни за начални и крайни, затова и се получава, че събираме всичките числа в \(T^{m-1}=R\). Предоставяме код, където при вече намерена матрица на преходите, намираме и броят валидни оцветявания на таблица \(n\)x\(m\).</p>
                        <div id="find-answer-placeholder"></div>
                        <p class="text-format">В следващия интерактивен пример могат да се въвеждат различни стойности за размерите на таблицата и да се пресмятат матриците \(T\) и \(T^{m-1}\). Също така се показват номерираните профили в реда, в който са и матриците и крайният отговор за съответните размери на таблицата. Максималната позволена стойност за \(n\) e 4. Всички сметки се извършват по модул 97!</p>
                        <div class="dpProfileExample">
                            <div class="row">
                                <div class="col-md-3 col-lg-2">
                                    <div class="form-group float-right">
                                        <input class="form-control col-4 n" style="float: right" maxLength="1" onkeypress="return isDigit(event)"/>
                                        <label for="n" class="label-input" style="float: right">\(n\):</label>
                                    </div>
                                    <div class="form-group float-right" style="clear: both">
                                        <input class="form-control col-5 m" style="float: right" maxLength="2" onkeypress="return isDigit(event)"/>
                                        <label for="m" class="label-input" style="float: right">\(m\):</label>
                                    </div>
                                    <button class="btn btn-primary calc" style="clear: both; float: right">Сметни!</button>
                                    <p class="answer" style="clear: both; float: right; margin-top: 5%; font-weight: bold"></p>
                                </div>
                                <div class="col-md-9 col-lg-10">
                                    <div class="row justify-content-center profiles"></div>
                                    <div class="row">
                                        <div class="col-sm-5 text-center">
                                            <p class="T"></p>
                                        </div>
                                        <div class="col-sm-7 text-center">
                                            <p class="Tm"></p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <p class="text-format">Последно ще кажем, че не винаги този подход при динамичното по профил е най-удачен, нещата зависят от конкретните ограничения. Ако няма малко измерение, то \(O(2^{3n})\) или най-общо казано сложността за извършване на умножението на матрици при намиране на \(T^2\) може да е твърде голяма. Тогава ако все пак няма твърде голямо измерение е най-удачно стандартното намиране на динамичното, което вече описахме (със сложност \(O(m*2^{2n})\) за нашата задача). Въпреки това част от нещата са добри практики - намирането на валидните изначално профили, както и за всеки профил с кои и по колко начина е съвместим. Така стандартният начин се забързва малко.</p>
                    </div>
                </div>

                <div class="lesson-part-position">
                    <button class="btn btn-secondary">4. Задачата за покритието с домина</button>
                    <div id="fourthPart">

                    </div>
                </div>

            </div>
            
            <div id="footer-placeholder"></div>
        </div>
    </body>
</html>