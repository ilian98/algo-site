<!DOCTYPE html>
<html>
    <head>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-Y8NQ36XMJS"></script>
		<script>
		  window.dataLayer = window.dataLayer || [];
		  function gtag(){dataLayer.push(arguments);}
		  gtag('js', new Date());

		  gtag('config', 'G-Y8NQ36XMJS');
		</script>
        
        <link rel="shortcut icon" href="/algo-site/images/favicon.ico">
        <link type="text/css" rel="stylesheet" href="/algo-site/node_modules/bootstrap/dist/css/bootstrap.min.css"  media="screen,projection"/>
        <link type="text/css" rel="stylesheet" href="/algo-site/styles/style.css"  media="screen,projection"/>
        <link type="text/css" rel="stylesheet" href="/algo-site/styles/lesson.css"  media="screen,projection"/>
        <link type="text/css" rel="stylesheet" href="/algo-site/node_modules/@highlightjs/cdn-assets/styles/github-dark.min.css">
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
        <script type="text/javascript" src="/algo-site/node_modules/jquery/dist/jquery.slim.min.js"></script>
        <script type="text/javascript" src="/algo-site/node_modules/jquery/dist/jquery.min.js"></script>
        <script type="text/javascript" src="/algo-site/node_modules/@popperjs/core/dist/umd/popper.min.js"></script>
        <script type="text/javascript" src="/algo-site/node_modules/bootstrap/dist/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="/algo-site/node_modules/snapsvg/dist/snap.svg-min.js"></script>
        <script id="MathJax-script" async src="/algo-site/node_modules/mathjax/es5/tex-chtml.js"></script>
        <script type="text/javascript" src="/algo-site/node_modules/@highlightjs/cdn-assets/highlight.min.js"></script>
        <script type="text/javascript" src="/algo-site/node_modules/opentype.js/dist/opentype.min.js"></script>
        <script type="text/javascript" src="/algo-site/js/main.js"></script>
        <script type="text/javascript" src="/algo-site/js/mathematical_lessons/2-SAT.js"></script>
        <script type="text/javascript" src="/algo-site/js/graph_drawer/graph.js"></script>
        <script type="text/javascript" src="/algo-site/js/graph_drawer/graph_positioning.js"></script>
        <script type="text/javascript" src="/algo-site/js/graph_drawer/graph_drawer.js"></script>
        <title>2-SAT</title>
    </head>
    <body>
        <header>
            <div id="nav-placeholder"></div>
            <nav aria-label="breadcrumb" class="unselectable">
                <ol class="breadcrumb">
                    <li class="breadcrumb-item" style="z-index:0">
                        <a href="/algo-site/pages/mathematical_lessons.html" class="text-danger">Математични</a>
                    </li>
                    <li class="breadcrumb-item active" style="z-index:0" aria-current="page">2-SAT</li>
                    <li class="ml-auto">Последна промяна: 26.11.2020</li>
                </ol>
            </nav>
        </header>
        
        <div class="wrapper" tabindex="-1">
            <div class="content">            
                <h1 align="center">2-SAT</h1>

                <div class="lesson-part-position">
                    <button class="btn btn-secondary">1. Какво представлява 2-SAT задачата?</button>
                    <div id="firstPart">
                        <p class="text-format">Ще започнем по отдалеч и първо ще поговорим само за <i>SAT</i> задачата (SAT идва от satisfiability - удовлетворимост). <i>SAT</i> задачата е много проста - трябва да определим възможно ли е булева формула да бъде удовлетворена, т.е. да приеме стойност истина. Нека първо да дефинираме какво ще разбираме под булева формула. Булева формула ще наричаме формула, в която са използвани единствено булеви променливи, скоби и операциите: логическо <b>и</b>, логическо <b>или</b> и логическо отрицание. Обикновено логическото отрицание е с най-голям приоритет, а логическо <b>или</b> с най-малък. Променливите ще означаваме с малки латински букви (възможно е и с индекси) - \(a_1,a_2,b, \dots \), логическата операция <b>и</b> с \(\&\&\), логическата операция <b>или</b> с \(||\), а логическо отрицане на някоя променлива \(a\) с \(!a\) (както в езика <i>C++</i>). Възможна булева формула е следната: \((a||b||c)\&\&(!a||!b||d)\). Булевите променливи приемат само стойности истина и лъжа, като ние за краткост ще ги означаваме съответно с 1 и 0. Така предната формула е удовлетворима - например при \(a=b=d=1\) и \(c=0\). Ако разгледаме обаче формулата: \((a||b)\&\&(a||!b)\&\&(!a||b)\&\&(!a||!b)\), можем да се убедим, че е неудовлетворима.</p>
                        <p class="text-format">Ние ще разглеждаме специален вид на формулите, който се нарича конюнктивна нормална форма (КНФ). Една формула е в КНФ, ако най-външните действия са само логическо <b>и</b>, които свързват формули, в които участват единствено променливи или логическо отрицание на променливи, свъзани с логическо <b>или</b>. Формулите в миналия абзац са в КНФ, а тези не са: \((!a\&\& b)||(!c)\), \((a||(b\&\& c))\&\&(!a||!b)\). На някой може да му изглежда, че се ограничаваме, като разглеждаме формулите само в КНФ, но това не е така, защото всяка формула може да се сведе до КНФ! Така например, ако имаме операцията <b>xor</b>, то лесно можем да се убедим, че \(a\land b\equiv(a||b)\&\&(!a||!b)\). Друг пример как можем да сведем предната формула \((a||(b\&\& c))\&\&(!a||!b)\) в КНФ е като използваме дистрибутивните закони за логическо <b>и</b> и логическо <b>или</b>: \((a||(b\&\& c))\&\&(!a||!b)\equiv\) \(((a||b)\&\&(a||c))\&\&(!a||!b)\equiv\) \((a||b)\&\&(a||c)\&\&(!a||!b)\). Подобни преобразувания показват как в повечето случаи лесно можем да превръщаме някои формули до КНФ, защото в общия случай има общ алгоритъм, от който може да се получи много дълга формула.</p>
                        <p class="text-format">Обикновено при <i>SAT</i> задачата, когато разглеждаме дали булеви формули могат да бъдат удовлетворени, си мислим, че са в КНФ. За съжаление в общия случай това е задача от класа <i>NP</i>, т.е. не е известен полиномиален алгоритъм, който да я решава. Дори е една от най-известните <i>NP</i> задачи. Тя е даже от класа <i>NP</i>-пълни задачи, което ще рече, че всяка задача от класа <i>NP</i> може да бъде сведена за полиномиално време до <i>SAT</i> задачата. Нека разгледаме един много лесен частен случай: 1-<i>SAT</i> задачата. При нея формулите, които са свързвани с логическо <b>и</b>, не съдържат логическо <b>или</b>, т.е. съдържат само една променлива. Никоя от досега разгледаните булеви формули не е такава, такива са например: \(!a\), \(!a\&\&!b\&\& a\), \(a\&\&!b\&\&!c\). Ще казваме, че такива булеви формули са в 1-<i>SAT</i> форма. Лесно се вижда, че при 1-<i>SAT</i> задачата е тривиално да преценим кога имаме удовлетворимост или по-точно, кога нямаме. Единственият случай да не можем да удовлетворим формулата е, ако тя съдържа някоя променлива и отрицанието ѝ. В останалите случаи просто даваме стойност на променливата 1, ако участва във формулата без отрицание, и стойност 0, ако участва във формулата с отрицание. Така вторият пример от преди малко, е неудовлетворима формула, заради променливата \(a\), а третият пример е удовлетворим, само ако \(a=1\), \(b=c=0\). Тук е ясно, че този "алгоритъм" е с линейна сложност спрямо дължината на формулата, а в някои случаи би могло да е и линеен спрямо броя променливи.</p>
                        <p class="text-format">Аналогично 2-<i>SAT</i> задачата също е частен случай на общата задача, при който формулите, които са свързани с логическо <b>и</b>, съдържат най-много едно логическо <b>или</b>, т.е. съдържат най-много по две променливи. Аналогично, ще казваме, че такива формули са в 2-<i>SAT</i> форма. Разбира се, всички формули които са в 1-<i>SAT</i> форма са и в 2-<i>SAT</i> форма. Формули, които са в 2-<i>SAT</i> форма, но не и в 1-<i>SAT</i> форма са например: \(a\&\&(!b||c)\), \((a||!b)\&\&(!a||b)\). В следващите точки ще опишем алгоритъм, който решава задачата за линейно време спрямо дължината на формулата. Интересно е, че тази задача е като баланс между известните решими в полиномиално време задачи и тези, за които не се знае. Ако малко усилим тази задача, получаваме задача, за която няма известно полиномиално решение. Така например 3-<i>SAT</i> задачата е в <i>NP</i>. Също така min/max 2-<i>SAT</i> задачата, в която търсим решение с минимален/максимален брой единици е в <i>NP</i>. В общия случай дори и не можем и да преброим решенията на дадена формула в 2-<i>SAT</i> форма за полиномиално време.</p>
                    </div>
                </div>

                <div class="lesson-part-position">
                    <button class="btn btn-secondary">2. Свеждане до граф на импликациите.</button>
                    <div id="secondPart">
                        <p class="text-format">Идеята за решаване на формула в 2-<i>SAT</i> форма е следната. Бихме искали да знаем, когато присвоим на някоя променлива дадена стойност, то какво следва за другите променливи. Понеже най-въшното действие във формулите е логическо <b>и</b>, то за да е удовлетворен цялата формула, искаме всяка подформула с логическо <b>или</b> да бъде удовлетворена. Затова ще изразим логическото <b>или</b> в алтернативна форма. Ще използваме бинарната логическата операция импликация, която ще означаваме с \(\to\). Тя има следната истинна таблица:</p>
                        <div class="col-2">
                            <table class="table table-dark table-bordered">
                                <tbody>
                                    <tr>
                                        <td>\(a\)</td><td>\(b\)</td><td>\(a\to b\)</td>
                                    </tr>
                                    <tr>
                                        <td>0</td><td>0</td><td>1</td>
                                    </tr>
                                    <tr>
                                        <td>0</td><td>1</td><td>1</td>
                                    </tr>
                                    <tr>
                                        <td>1</td><td>0</td><td>0</td>
                                    </tr>
                                    <tr>
                                        <td>1</td><td>1</td><td>1</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="text-format">Смисълът на тази операция е като математическото следователно - искаме да кажем, че ако едно твърдение е истина (a), то друго твърдение също трябва да е истина (b). Както се вижда, при тази операция можем да получим 0, само ако първата променлива e 1, а втората е 0. Нека например имаме \(x||y\). Тогава ако \(x=1\), нямаме претенции за стойността на \(y\). Но ако \(x=0\), тогава за да удовлетворим тази формула, <b>трябва</b> \(y=1\). Това можем да запишем с импликация по следния начин: \(!x\to y\), което е напълно еквивалетно на началната формула \(x||y\). По-рано казахме, че искаме да знаем за всяка променлива какво следва, ако ѝ присвоим дадена стойност. Затова аналогично, ако разсъждаваме за \(y\) трябва да имаме импликацията \(!y\to x\), която също е еквивалентна на началната формула. Така тези две импликации ни описват точно какво трябва да се случи в зависимост от това какви стойности присвоим на \(x\) и \(y\). По този начин можем за всяко едно от логическите <b>или</b>-та да разпишем съответни импликации на това какво трябва да следва при присвояване на дадена стойност на някоя променлива. Понеже те са обединени с логическо <b>и</b>, то всички тези импликации трябва да са верни. Цялата тази информация най-компактно и приложимо можем да я запишем в граф, чиито върхове са променливите и техните отрицания, а ребрата са именно тези импликации. Следният интерактивен пример илюстрира как от формула, която е в 2-<i>SAT</i> форма, можем да получим така наречения <i>граф на импликациите</i>:</p>
                        <div class="twoSATexample1 row">
                            <div class="form-group col-lg-5">
                                <label for="formula" class="label-input" style="float: left">Формула:</label>
                                <input class="form-control col-9 col-md-6 col-lg-9 formula" maxLength="40"/>
                            </div>
                            <div class="graphExample col-lg-7">
                                <button class="btn btn-primary make">Направи графа!</button>
                                <svg class="graph" width="100%" viewBox="0 0 300 150" style="margin-top: 2%"></svg>
                                <svg class="svg-save" width="100" height="100" viewBox="0 0 300 150"></svg>
                                <button class="btn btn-primary save" style="float: right">
                                    <svg class="bi" width="24px" height="24px" fill="currentColor">
                                        <use xlink:href="/algo-site/node_modules/bootstrap-icons/bootstrap-icons.svg#download"/>
                                    </svg>
                                </button>
                                <canvas class="canvas-save"></canvas>
                            </div>
                        </div>
                        <p class="text-format">Нещо, което следва да уточним е следното - може да има самостоятелна променлива (или отрицание на променлива) като формула, обградена с логическо <b>и</b>. Ако например имаме самостоятелно променливата \(x\), това означава, че за да е удовлетворима цялата формула трябва \(x=1\). Това с импликации можем да го наложим по-следния начин: \(!x\to x\), така ако се опитаме да сложим \(x=0\) ще стигнем до противоречие. Аналогично ако имаме самостоятелно \(!x\), то ще имаме импликацията \(x\to !x\). Разсъждението преди малко показва и начина на мислене, като имаме този граф. Идеята е, че ако приемем, даден връх за правилно твърдение, то импликациите показват какво следва от него за останалите променливи. Проблем възниква, както преди малко, ако по някакъв начин стигнем до връх, който отрича началното твърдение.</p>
                    </div>
                </div>

                <div class="lesson-part-position">
                    <button class="btn btn-secondary">3. Алгоритъм за решаване на задачата</button>
                    <div id="thirdPart">
                        <p class="text-format">Последните изречения на предната точка са основните за алгоритъма, който решава задачата. Това, което споменахме е следното. Ако БОО (<a class="info">...</a><a class="info" style="display: none">без ограничение на общността, т.е. няма значение какво ще изберем, защото разсъжденията са аналогични, затова просто фиксираме случай</a>) сме приели, че връх \(x\) ще е правилно твърдение (т.е. \(x\) ще е 1) и движейки се по ребрата (импликациите), достигнем връх \(!x\), то получаваме противоречие за каква стойност трябва да има \(x\). Другият начин, когато получаваме нещо нередно е ако от връх \(x\) има път до връх \(y\) и има път и до връх \(!y\). Но в този случай можем да забележим, че това не се различава от предния случай, т.е. можем да намерим път до връх \(!x\). Наблюдението е следното, ако имаме например импликация \(a\to b\) (която съответсва на \(!a||b\) ), то имаме и импликация, която е \(!b\to!a\) - в обратната посока между отрицанията на променливите. Забележете, че това важи дори и за импликациите, които следват от една променлива, защото се получава същата импликация (например от \(x\to !x\), получаваме същото). Това означава, че като имаме път от връх \(x\) до връх \(!y\), получаваме път от връх \((!(!y)=y)\) до връх \(!x\). Така ако сглобим пътят, който имахме от връх \(x\) до връх \(y\) с този път от връх \(y\) до връх \(!x\) ще получим път от \(x\) до \(!x\) (не е нужно полученият път да е прост, но лесно бихме конструирали от него прост път). Последното, което доказахме, означава, че ако приемем връх за правилно твърдение, то той не би участвал в решението, ако има път от него до върха с обратното твърдение (казано по друг начин, ако има път от връх \(a\) до връх \(!a\), то \(a\) не може да е единица и обратното). Това ни дава и НДУ (<a class="info">...</a><a class="info" style="display: none">необходимо и достатъчно условие</a>) кога нямаме решение - нямаме решение ако има променлива \(x\), такава че в графът на импликациите има път от връх \(x\) до връх \(!x\), както и път в обратната посока - от връх \(!x\) до връх \(x\). Това е вярно, защото ако съществуват тези два пътя, то няма валидна стойност, която да присвоим на \(x\) без да получим противоречие от импликациите. Ако няма такава променлива, то имаме поне едно решение.</p>
                        <p class="text-format">Можем да преразкажем последното условие по следния начин. Дадена формула в 2-<i>SAT</i> форма е неудовлетворима\(\iff\) за някоя променлива \(x\) съществува цикъл в <i>графа на импликациите</i> между върха на \(x\) и върха на \(!x\). Това лесно може да се открие за ориентиран граф, какъвто е и <i>графът на импликациите</i>. Ако разглеждаме силно-свързаните му компоненти (<a class="info">...</a><a class="info" style="display: none">първо погледнете темата за силно-свързани компоненти</a>), то търсим дали има такава компонента, в която да се намира променлива и нейното отрицание. Следният интерактивен пример онагледява силно-свързаните компоненти на <i>графа на импликациите</i> за дадена формула в 2-<i>SAT</i> форма (едноцветните върхове са в една силно-свързана компонента):</p>
                        <div class="twoSATexample2 row">
                            <div class="form-group col-lg-5">
                                <label for="formula" class="label-input" style="float: left">Формула:</label>
                                <input class="form-control col-9 col-md-6 col-lg-9 formula" maxLength="40"/>
                                <br>
                                <label for="solution" style="float: left; margin-right: 10px; margin-bottom: 0px">Решение:</label>
                                <p class="solution"></p>
                            </div>
                            <div class="graphExample col-lg-7">
                                <button class="btn btn-primary show">Покажи компонентите!</button>
                                <svg class="graph" width="100%" viewBox="0 0 300 150" style="margin-top: 2%"></svg>
                                <svg class="svg-save" width="100" height="100" viewBox="0 0 300 150"></svg>
                                <button class="btn btn-primary save" style="float: right">
                                    <svg class="bi" width="24px" height="24px" fill="currentColor">
                                        <use xlink:href="/algo-site/node_modules/bootstrap-icons/bootstrap-icons.svg#download"/>
                                    </svg>
                                </button>
                                <canvas class="canvas-save"></canvas>
                            </div>
                        </div>
                        <p class="text-format">Единствено остана да изясним един важен въпрос. Когато имаме решение как да намерим едно такова. Това не е тривиален въпрос. Има лесен начин, използвайки вече намерените силно-свързани компоненти. Стандартният алгоритъм (на Косаруджо), с който се намират, ги обхожда в топологичен ред. Нека сме ги номерирали в този ред. Нека \(a\) е номерът на компонентата на връх \(x\), а \(b\) е номерът на компонентата на връх \(!x\). Ако \(b \lt a\), то е възможно да има потенциален път между върховете \(!x\) и \(x\), но е сигурно, че няма път между тях в обратната посока. Това означава, че можем да сложим стойност истина на \(x\). В обратния случай трябва да сложим стойност лъжа на тази променлива. Следният код реализира описаният досега алгоритъм за удовлетворяване на формула в 2-<i>SAT</i> форма:</p>
                        <div id="2-SAT_algorithm" class="placeholder"></div>
                        <p class="text-format">Някой може да се зачуди дали последният прост алгоритъм за намиране на решение, в действителност намира правилно решение. От това, което казахме досега за разсъжденията в <i>графа на импликациите</i>, би трябвало като фиксираме стойността на връх (променлива), то с това да се фиксират и стойностите на останалите променливи от силно-свързната компонента. Може да се забележи, че наблюдението за импликации в обратната посока, ни осигурява за всяка компонента \(C\) <i>дуална</i> на нея \(!C\), в която има същите променливи като в \(C\) само че с отрицания, и ребра в обратната посока (<a class="info">...</a><a class="info" style="display: none">за по-добро разбиране погледнете силно-свързаните компоненти на <i>графа на импликациите</i> за удовлетворима формула</a>). По този начин е гарантирано, че този алгоритъм работи <b>по един и същ начин</b> за всички променливи от дадена компонента, защото симетрично се попълва и <i>дуалната</i> компонента, и няма как да има някакво смесване.</p>
                    </div>
                </div>
            </div>
                
            <div id="footer-placeholder"></div>
        </div>
    </body>
</html>