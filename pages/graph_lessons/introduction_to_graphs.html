<!DOCTYPE html>
<html>
    <head>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-Y8NQ36XMJS"></script>
		<script>
		  window.dataLayer = window.dataLayer || [];
		  function gtag(){dataLayer.push(arguments);}
		  gtag('js', new Date());

		  gtag('config', 'G-Y8NQ36XMJS');
		</script>
        
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
        
        <link rel="shortcut icon" href="/algo-site/images/favicon.ico">
        <link type="text/css" rel="stylesheet" href="/algo-site/node_modules/bootstrap/dist/css/bootstrap.min.css"  media="screen,projection"/>
        <link type="text/css" rel="stylesheet" href="/algo-site/styles/style.css" media="screen,projection"/>
        <link type="text/css" rel="stylesheet" href="/algo-site/styles/lesson.css" media="screen,projection"/>
        <link type="text/css" rel="stylesheet" href="/algo-site/node_modules/@highlightjs/cdn-assets/styles/github-dark.min.css">
        
        <script type="text/javascript" src="/algo-site/node_modules/jquery/dist/jquery.slim.min.js"></script>
        <script type="text/javascript" src="/algo-site/node_modules/jquery/dist/jquery.min.js"></script>
        <script type="text/javascript" src="/algo-site/node_modules/@popperjs/core/dist/umd/popper.min.js"></script>
        <script type="text/javascript" src="/algo-site/node_modules/bootstrap/dist/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="/algo-site/node_modules/snapsvg/dist/snap.svg-min.js"></script>
        <script id="MathJax-script" async src="/algo-site/node_modules/mathjax/es5/tex-chtml.js"></script>
        <script type="text/javascript" src="/algo-site/node_modules/@highlightjs/cdn-assets/highlight.min.js"></script>
        <script type="text/javascript" src="/algo-site/node_modules/opentype.js/dist/opentype.min.js"></script>
        <script type="text/javascript" src="/algo-site/js/main.js"></script>
        <script type="text/javascript" src="/algo-site/js/graph_drawer/graph.js"></script>
        <script type="text/javascript" src="/algo-site/js/graph_drawer/graph_positioning.js"></script>
        <script type="text/javascript" src="/algo-site/js/graph_drawer/graph_drawer.js"></script>
        <script type="text/javascript" src="/algo-site/js/graph_drawer/graph_controller.js"></script>
        <script type="text/javascript" src="/algo-site/js/graph_lessons/introduction.js"></script>
        <title>Увод в графите</title>
    </head>
    <body>
        <header>
            <div id="nav-placeholder"></div>
            <nav aria-label="breadcrumb" class="unselectable">
                <ol class="breadcrumb">
                    <li class="breadcrumb-item">
                        <a href="/algo-site/pages/graph_lessons.html" class="link-danger">Графи</a>
                    </li>
                    <li class="breadcrumb-item">
                        <a class="link-secondary">Увод в графите</a>
                    </li>
                    <li class="ms-auto">Последна промяна: 07.09.2021</li>
                </ol>
            </nav>
        </header>
        
        <div class="wrapper" tabindex="-1">
            <div class="content">            
                <h1 align="center">Увод в графите</h1>
                
                <ul class="dropdown-menu vertex">
                    <li><a class="dropdown-item unselectable remove-vertex">Изтрий върха</a></li>
                    <li><a class="dropdown-item unselectable change-name">Промени името</a></li>
                    <li><a class="dropdown-item unselectable add-css">Сложи CSS стил</a></li>
                    <li><a class="dropdown-item unselectable add-css-name">Сложи CSS стил на името</a></li>
                </ul>
                <ul class="dropdown-menu edge">
                    <li><a class="dropdown-item unselectable remove-edge">Изтрий реброто</a></li>
                    <li><a class="dropdown-item unselectable change-weight">Промени теглото</a></li>
                    <li><a class="dropdown-item unselectable add-css">Сложи CSS стил</a></li>
                </ul>
                <ul class="dropdown-menu weight">
                    <li><a class="dropdown-item unselectable change-weight">Промени теглото</a></li>
                    <li><a class="dropdown-item unselectable add-css">Сложи CSS стил</a></li>
                </ul>           
                <ul class="dropdown-menu save-menu">
                    <li><a class="dropdown-item unselectable txt">Изтегли като txt</a></li>
                    <li><a class="dropdown-item unselectable edge-list">Изтегли като сп. на ребрата</a></li>
                    <li><a class="dropdown-item unselectable svg">Изтегли като svg</a></li>
                    <li><a class="dropdown-item unselectable png">Изтегли като png</a></li>
                </ul>
                <div class="modal fade" id="settingsModal" tabindex="-1" aria-labelledby="settingsModalLabel" aria-hidden="true">
                    <div class="modal-dialog">
                        <div class="modal-content" style="max-height: 100%; overflow-y: auto">
                            <div class="modal-header">
                                <h5 class="modal-title" id="settingsModalLabel">Настройки на графа</h5>
                                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                            </div>
                            <div class="modal-body" style="text-align: justify">
                                <div class="row mb-3">
                                    <div class="slidecontainer">
                                        <input type="range" min="1" max="10" value="5" class="slider range-vers" id="rangeVers">
                                    </div>
                                    <div class="slider-text unselectable">
                                        <span>Брой върхове: </span>
                                        <span class="slider-value-vers" style="color: red; font-weight: bold"></span>
                                    </div>
                                </div>
                                <div class="row mb-3">
                                    <div class="col-sm">
                                        <div class="form-check">
                                            <input class="form-check-input" type="radio" name="direction" id="undirected" checked>
                                            <label class="form-check-label unselectable" for="undirected">Неориентиран граф</label>
                                        </div>
                                        <div class="form-check">
                                            <input class="form-check-input" type="radio" name="direction" id="directed">
                                            <label class="form-check-label unselectable" for="directed">Ориентиран граф</label>
                                        </div>
                                    </div>
                                    <div class="col-sm">
                                        <div class="form-check">
                                            <input class="form-check-input" type="checkbox" value="" id="weighted">
                                            <label class="form-check-label unselectable" for="weighted">Претеглен граф</label>
                                        </div>
                                        <div class="form-check">
                                            <input class="form-check-input" type="checkbox" value="" id="multi">
                                            <label class="form-check-label unselectable" for="multi">Мултиграф</label>
                                        </div>
                                    </div>
                                </div>
                                <div class="row mb-3">
                                    <div class="slidecontainer">
                                        <input type="range" min="15" max="30" value="20" class="slider range-rad" id="rangeRad">
                                    </div>
                                    <div class="slider-text unselectable">
                                        <span>Големина на върховете: </span>
                                        <span class="slider-value-rad" style="color: red; font-weight: bold"></span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal fade" id="infoModal" tabindex="-1" aria-labelledby="infoModalLabel" aria-hidden="true">
                    <div class="modal-dialog">
                        <div class="modal-content" style="max-height: 100%; overflow-y: auto">
                            <div class="modal-header">
                                <h5 class="modal-title" id="infoModalLabel">Информация</h5>
                                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                            </div>
                            <div class="modal-body" style="text-align: justify">
                                Суича в лентата за графа управлява действието, което се изпълнява при влачене на връх. Когато е изключен, се започва чертаене на ребро, а когато е включен се премества върха.<br><br>
                                Използвайте бутона за настройките, за да отворите прозорец за управление на графа. Първият слайдър там е за определяне на броя върхове в графа - от 1 до 10. При промяна графът се изтрива и се появяват указания брой върхове на произволни места. Вторият плъзгач е за промяна на големината на върховете, като графът сам променя останалите характеристики в зависимост от тази големина.<br><br>
                                Нов връх на графа се добавя с двойно натискане на празно място. Всеки връх може да се натисне, с което да се появят различни опции за работа с него. При влачене на връх, се появяват опорни позиции. Връх, който е пуснат близо до опорна позиция се придвижва автоматично там. Всяко ребро с изключение на примките, може да се персонализира с влачене. По този начин се променя кривината на реброто. При натискане на ребро също се появяват различни опции за него.<br><br>
                                Всички компоненти на графа като цвят, големина и т.н., могат да се персонализират чрез написване на съответeн CSS код след избиране на опция за добавяне на CSS стил. Отделно се поддържа възможност за връщане на всяка промяна, както и изпълняването ѝ отново чрез бутоните в лявата част на функционалната лента. Бутоните в средата на лентата са за качване на текстов файл, в който е описан граф, както и за изтегляне на направения граф в различни формати.
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="lesson-part-position">
                    <button class="btn btn-secondary">1. Какво представляват графите?</button>
                    <div class="lesson-part">
                        <p class="text-format">Най-просто казано това са някакви неща, между които има някакви връзки. Например маршрутна мрежа, където „нещата“ са градове, а тези „връзки“ са пътни връзки. Има множество други примери, които могат да се моделират по такъв начин (приятелства, йерархия във фирма, ...). Те представляват удобна абстракция, която е част от много състезателни задачи.</p>
                        <p class="text-format bold">Формално определение и стандартни означения: Граф \(G\) е наредена двойка от множество от елементи (наречени върхове) \(V\) и (мулти)множество от (не)наредени двойки (наречени ребра) \(E\) между тях. Накратко: \(G(V,E)\). Броят върхове обикновено се бележи с \(n\), а броят ребра с \(m\).</p>
                        <p class="text-format">Тази тема е много важна в състезателната (и практическата) информатика. Има разнообразни алгоритми, които могат да се прилагат в графи. Понятията в тази тема са изключително много, затова ще ги въвеждаме малко, по-малко, когато ни трябват. Тук ще покажем само за най-основните.</p>
                    </div>
                </div>
                <div class="lesson-part-position">
                    <button class="btn btn-secondary">2. Основни понятия в теорията на графите.</button>
                    <div class="lesson-part">
                        <p class="text-format">Всеки граф трябва да има поне един връх. Възможно е множеството от ребрата да е празно. Такъв граф наричаме <i>празен граф</i>. Самите върхове обикновено номерираме последователно с числата \(1,2,...,n\). Първо ще поговорим за два основни вида графи, които се получават в зависимост от това дали ребрата в графа имат ориентация или не.</p>
                        <ul>
                            <div>
                                <div class="graph-container" style="float: right; margin-left: 2%">
                                    <svg class="graphExample1" viewBox="0 0 300 300" style="width: 20vw"></svg>
                                </div>
                                <li class="dashed-list text-format" style="text-indent: 0px; margin-bottom: 2%">ориентирани – както казахме ребрата могат да представляват наредени двойки (при тях редът има значение), т.е. връзката има посока. Например ако графът моделира йерархията във фирма е важно дали връзката е шеф-подчинен или подчинен-шеф. Представяме пример за такъв граф. Тази „картинка“ с кръгчета и насочени отсечки е стандартен начин за изобразяване на граф от човек. Множеството от върховете е \(V=\{1,2,3,4,5\}\), а на ребрата - \(E=\{(1,2),(1,3),(1,4),(2,5),(3,5)\}\). Забележете, че за всяка двойка в множеството \(E\), на първо място седи върхът, от който излиза реброто, а на второ, върхът, в който влиза реброто. В случая графът може да моделира йерархията във фирма, като човекът под номер 1 е най-големият шеф, а например човекът под номер 5 има двама преки началници. Понеже графът е ориентиран, то би могло да съществува и реброто \((2,1) \ne (1,2)\). Но то няма смисъл, ако графът представя йерархията във фирма. Тогава може този граф да показва познанствата на хора (ако приемем, че познанството не е двустранно). Обърнете внимание, че един и същ граф може да изобразява различни неща.</li>
                            </div>
                            <div style="clear: both">
                                <div class="graph-container" style="float: right; margin-left: 2%">
                                    <svg class="graphExample2" viewBox="0 0 300 300" style="width: 20vw"></svg>
                                </div>
                                <li class="dashed-list text-format" style="text-indent: 0px">неориентирани – ребрата в тези графи са ненаредени двойки. Забележете, че тук отсечките са ненасочени. Множеството от върховете е отново \(V=\{1,2,3,4,5\}\), а \(E=\{\{1,2\},\{1,3\},\{1,4\},\{2,5\},\{3,5\}\}\). Начина, по който означаваме ребрата с двуелементни множества е коректен по отношение на смисъла, че няма ориентация, но не е често срещан. Обикновено (и за сходство с ориентирания случай) ребрата отново се означават с кръгли скоби, като се уточнява, че говорим за неориентиран граф. Така че пак ще запишем \(E=\{(1,2),(1,3),(2,4),(2,5),(3,5)\}\). Тук за двойките няма значение разположението на върховете, а само кои са.</li>
                            </div>
                        </ul>
                        <p class="text-format" style="clear: both">Има и така наречените смесени графи, където имаме и ориентирани, и неориентирани ребра. Те се срещат доста рядко, така че обикновено боравим с ориентиран или неориентиран граф. Ще отбележим, че това е най-важното разделение при графи. За голяма част от алгоритмите има значение с какъв вид граф се работи. Някои алгоритми са приложими само за единия тип графи, други стават по-сложни.</p>
                        <div class="graph-container" style="float: right; margin-left: 2%">
                            <svg class="graphExample3" viewBox="0 0 300 300" style="width: 10vw"></svg>
                        </div>
                        <p class="text-format">Още един важен тип графи са мултиграфите. В определението ни за граф това присъства като възможност, защото е казано, че множеството \(E\) може да е мултимножество. Всъщност това е разликата с обикновените графи - при мултиграфите е възможно да имаме ребра, които на практика не могат да се различат по свързаните върхове. Ето пример за ориентиран мултиграф. Имаме четири ребра \((1,2)\). Забележете, че множеството с върхове в определението е посочено само като множество, така че при върховете няма повторения, защото искаме да различаваме върховете по имената им.</p>
                        <p class="text-format bold" style="clear: both">Определение: Степен на връх \(v\) в неориентиран граф наричаме броя на ребрата, които излизат от връх \(v\), и означаваме с \(d(v)\). Формално \(d(v)=|\{u \mid (v,u) \in E\}|\) \(=|\{u \mid (u,v) \in E\}|\). При ориентирани графи има две понятия за степен - полустепен на входа и полустепен на изхода. Полустепен на входа на връх \(v\) наричаме броя влизащи ребра във върха и означаваме с \(d^{-}(v)\), а полустепен на изхода наричаме броя излизащи ребра от върха и означаваме с \(d^{+}(v)\). Математически: \(d^{-}(v)=|\{u \mid (u,v) \in E\}|\) и \(d^{+}(v)=|\{u \mid (v,u) \in E\}|\). В случая на ориентиран граф е прието степента на връх да е сумата от двете полустепени, т.е. \(d(v)=d^{-}(v)+d^{+}(v)\).</p>
                        <p class="text-format">Това понятие на повечето места се ползва за определението <i>изолиран връх</i> - връх \(v\) е изолиран \(\iff d(v)=0\), т.е. такъв връх не е свързан с други върхове от графа. Тук е момента да кажем, че това определение за изолиран връх пропуска един случай, в който също е удачно да се счита върха за изолиран. В графите има специални ребра наречени <i>примки</i>. Едно ребро е примка, когато е от вида \((v,v)\), т.е. свързва един и същ връх. Ако един връх има само ребра, които са примки, то той продължава да не е свързан с другите върхове. Затова определението за изолиран връх, което ние ще ползваме е следното: връх \(v\) е изолиран \(\iff |\{u \ne v \mid (u,v) \in E \) или \( (v,u) \in E\}|=0\). Също така ще отбележим, че понятието за степен на връх в неориентиран граф не е много точно, ако в графа може да има примки. Поради ред причини, всяка примка се брои два пъти в степента на съответния връх (за двата си края), т.е. в този случай степента на връх \(v\) е \(d(v)=|\{u \ne v \mid (v,u) \in E\}|+\) \(2*|\{u=v \mid (v,u) \in E\}|\). За да се изяснят тези неща, е даден примерен неориентиран граф с две примки на връх 1 и една примка на връх 2, където за всеки връх е записана степента, като графът може да се променя, а степените се обновяват автоматично.</p>
                        <div class="graphExample4 row">
                            <div class="col-sm text-center">
                                <div class="row settings-panel"></div>
                                <div class="graph-container">
                                    <svg class="graph" viewBox="0 0 300 300" style="height: 50vh; max-width: 100%"></svg>
                                </div>
                            </div>
                            <div class="col-sm text-center my-auto">
                                <button class="btn btn-primary mb-2 default">Начален пример</button>
                                <table class="table table-dark table-bordered degree" style="width: auto; margin: auto">
                                </table>
                            </div>
                        </div>
                        <p class="text-format">В много случаи един граф да е мултиграф и да има примки усложнява нещата и при много алгоритми се налагат специфични частни случаи. Затова в повечето задачи се работи с графи, които не са мултиграфи и нямат примки. Такива графи ще наричаме <i>прости</i>. Забележете, че като говорим за <i>прост</i> граф, може да става дума както за ориентиран, така и за неориентиран.</p>
                        <p class="text-format bold">Определение: Един граф \(G'(V',E')\) е подграф на \(G(V,E)\) \(\iff V' \subseteq V\) и \(E' \subseteq E\).</p>
                        <p class="text-format bold">Определение: Връх \(u\) е съседен на връх \(v\) в граф \(G \iff (v,u) \in E\). Казваме още, че връх \(v\) има за съсед връх \(u\). Забележете, че в общия случай ако \(u\) е съсед на \(v\), то обратното не е задължително изпълнено. Обаче ако \(G\) е неориентиран, тогава съседството е двустранно и казваме, че върховете \(u\) и \(v\) са съседни.</p>
                        <p class="text-format">Вече можем да дефинираме едни от основните понятия в графите - път и цикъл. Неформално казано, път образуваме като тръгнем от някой начален връх, отидем до съседен връх, после до негов съседен и т.н. докато спрем на някой връх. Имаме цикъл, когато спрем на началния връх. Ето и формалните определения:</p>
                        <p class="text-format bold">Определение: Път в граф наричаме алтернираща поредица от върхове и ребра: \(v_1, e_1, v_2, e_2, ..., e_k, v_{k+1}\), където за всяко \(1 \le i \le k: e_i=(v_i, v_{i+1})\). Един път представлява цикъл, когато \(v_1=v_{k+1}\). Броят ребра \(k\), които участват, се нарича дължина на пътя\цикъла. Възможно е път да е съставен само от един връх, така че минималната дължина на път е 0.</p>
                        <p class="text-format">Когато не сме в мултиграф, то два върха еднозначно определят реброто между тях. Затова обикновено, когато говорим за път, разглеждаме само последователността от върховете на пътя. Същото важи и за цикли в графи, които не са мултиграфи. Една важна разновидност е така наречените <i>прости пътища</i>. Път е <i>прост</i>, когато всички върхове, които участват в него са различни. От това следва, че и ребрата не се повтарят. Този вид пътища са много важни, защото имат повече свойства и освен това винаги са краен брой. Аналогично имаме и понятие <i>прост цикъл</i>. При тях ще задължим освен върховете да са различни (с изключение на началния и крайния) и всички ребра да са различни. Тук е задължително да включим и ребрата, защото в неориентиран граф при ребро \((1,2)\), цикълът \(1,2,1\) не се брои за <i>прост</i>, въпреки че не се повтарят върхове освен 1. Идеята на <i>простия цикъл</i> е да няма тривиални повторения, затова не броим минаването два пъти по едно и също неориентирано ребро за такъв цикъл. Следва интерактивен пример, където за зададени върхове се намира минимален по-дължина прост път, както и цикъл през началния връх.</p>
                        <div class="graphExample5">
                            <div class="row">
                                <div class="col-sm">
                                    <div class="row justify-content-end mb-3">
                                        <div class="col-auto">
                                            <button class="btn btn-primary default">Начален пример</button>
                                        </div>
                                    </div>
                                    <div class="row justify-content-end mb-3">
                                        <label for="beg" class="col-auto col-form-label pe-0">Начален връх:</label>
                                        <div class="col-auto">
                                            <input class="form-control beg" maxLength="2" style="width: 2.5rem; max-width: 100%"/>
                                        </div>
                                    </div>
                                    <div class="row justify-content-end mb-3">
                                        <label for="end" class="col-auto col-form-label pe-0">Краен връх:</label>
                                        <div class="col-auto">
                                            <input class="form-control end" maxLength="2" style="width: 2.5rem; max-width: 100%"/>
                                        </div>
                                    </div>
                                    <div class="row justify-content-end">
                                        <div class="col-auto mb-2">
                                            <button class="btn btn-primary find">Намери!</button>
                                        </div>
                                        <p class="paths" style="text-align: right"></p>
                                    </div>
                                </div>
                                <div class="col-sm text-center">
                                    <div class="row settings-panel"></div>
                                    <div class="graph-container">
                                        <svg class="graph" viewBox="0 0 300 300" style="height: 40vh; max-width: 100%"></svg>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <p class="text-format">Както казахме, <i>простите</i> пътища и цикли намират голямо приложение. Затова, когато говорим за пътища и цикли ще имаме предвид, че те са <i>прости</i> освен ако не е уточнено друго допълнително. В неориентиран граф, когато между два върха има път, казваме още, че те са свързани. Едно важно понятие, което ще трябва по-нататък:</p>
                        <p class="text-format bold">Определение: Неориентиран граф \(G\) наричаме свързан \(\iff\) всеки два върха са свързани.</p>
                        <p class="text-format">Всички досегашни примери за неориентирани графи, без този с изолирания връх, са на свързани графи. Ясно е, че ако граф с повече от един връх има изолиран връх, то той няма как да е свързан, защото от изолирания връх няма път до другите върхове.</p>
                        <div class="graph-container" style="clear: both; float: right; margin-left: 2%">
                            <svg class="graphExample6" viewBox="0 0 300 300" style="width: 20vw"></svg>
                        </div>
                        <p class="text-format">Последно ще разгледаме графи, които са много приложими на практика и често срещани в задачите с графи. Можем да добавим допълнителни описания за всяко ребро, например дължина, време и т.н. Такива графи наричаме <i>претеглени графи</i>. Формална дефиниция е, че добавяме теглова функция \(f_w: E \to W\), където \(W\) е множество от възможните стойности на теглата. Най-често се работи с естествени числа за тегла на ребрата. За показания пример, графът би бил записан така: \(G(V,E,f_w)\), където \(f_w\) е функция дефинирана само за следните стойности - \(f_w((1,2))=1,\) \(f_w((1,3))=2,\) \(f_w((1,4))=3,\) \(f_w((2,5))=1\) и \(f_w((3,5))=2\).</p>
                        <div style="clear: both"></div>
                    </div>
                </div>

                <div class="lesson-part-position">
                    <button class="btn btn-secondary">3. Представяне в паметта.</button>
                    <div class="lesson-part">
                        <p class="text-format">Една от големите разлики в задачите с графи по информатика, в сравнение с тези по математика, е, че, обикновено, самите графи са дадени. Графичното представяне, макар да е много нагледно за хората, е крайно неудобно и нееднозначно за паметта на компютрите. Има разнообразни представяния, тук ще разгледаме най-приложимите от тях.</p>
                        <ul>
                            <li class="dashed-list text-format" style="text-indent: 0px; margin-bottom: 2%">матрица на съседство
                                <p>Това е едно от най-простите представяния и донякъде по традиция се започва с него, макар и следващото представяне да е най-популярното. Нека първо говорим за непретеглени <i>прости</i> графи. Както се вижда от името, самото представяне е всъщност една матрица с размери \(n\)x\(n\), обикновено се бележи с \(A\). Всяка клетка \(A[u][v]\) има стойност 1 или 0 в зависимост от това дали имаме ребро \((u,v)\) или не. Когато разглеждаме мултиграфи, то представянето се разширява и във всяка клетка се пише по колко ребра има между съответните два върха - матрицата вече не е задължително булева. Предоставен е пример, където на графа могат да се добавят ребра (включително мултиребра) и да се наблюдава матрицата му на съседство:</p>
                                <div class="graphExample7 row">
                                    <div class="col-sm text-center">
                                        <div class="row settings-panel"></div>
                                        <div class="graph-container">
                                            <svg class="graph" viewBox="0 0 300 300" style="height: 50vh; max-width: 100%"></svg>
                                        </div>
                                    </div>
                                    <div class="col-sm text-center my-auto">
                                        <button class="btn btn-primary mb-2 default">Начален пример</button>
                                        <table class="table table-dark table-bordered matrix" style="width: auto; margin: auto">
                                        </table>
                                    </div>
                                </div>
                                <p>Когато се прави матрица на съседство на неориентиран граф, лесно може да се забележи, че тя е симетрична относно главния диагонал - точно защото ребрата са и в двете посоки. Освен това числата по главния диагонал обозначават примки. Това важи и за ориентираните графи. Матрицата на съседство може да се прилага и в претеглени графи. Тогава в клетките на матрицата се записват самите тегла на съответните ребра, като често няма тегло 0, и отново се използва нулата за липса на ребро.</p>
                                <p>Следва да кажем какви са предимствата на това представяне на графите. Едно от големите предимства, е че лесно се добавят и премахват ребра с константна сложност (<a class="info">...</a><a class="info" style="display: none">просто се достъпва и променя съответната клетка</a>). Друго предимство пак в тази връзка е, че с константна сложност може да се отговаря на въпроса дали между два върха има ребро. Това представяне има сериозни недостатъци, затова често се избягва. Паметта, която трябва, дори и при малко ребра, винаги е от порядъка на \(O(n^2)\). Докато много често графите имат ребра в порядъка само на \(O(n)\). Също съществен недостатък е, че ни трябва линейно време (спрямо броя върхове), за да намерим всичките съседи на даден връх.</p>
                            </li>
                            <li class="dashed-list text-format" style="text-indent: 0px; margin-bottom: 2%">списък на съседите
                                <p>Идеята на това представяне е за всеки връх да поддържаме списък на съседите му. Понеже обикновено върховете са номерирани с последователни числа от 1 до \(n\), то всъщност цялото представяне е масив от списъци - по този начин константно достъпваме списъка на всеки връх. Ако сме в неориентиран граф, то за реброто \((u,v)\), ще сложим връх \(v\) в списъка на \(u\), както и обратното - връх \(u\) в списъка на \(v\). При претеглени графи освен да слагаме връх в списък, слагаме и теглото на всяко ребро, обикновено двете заедно като наредена двойка (връх, тегло). Следва интерактивен пример за списъка на съседите на граф.</p>
                                <div class="graphExample8 row">
                                    <div class="col-sm text-center">
                                        <div class="row settings-panel"></div>
                                        <div class="graph-container">
                                            <svg class="graph" viewBox="0 0 300 300" style="height: 50vh; max-width: 100%"></svg>
                                        </div>
                                    </div>
                                    <div class="col-sm text-center my-auto">
                                        <button class="btn btn-primary mb-2 default">Начален пример</button>
                                        <table class="table table-dark table-bordered adjacency-list" style="width: auto; margin: auto">
                                        </table>
                                    </div>
                                </div>
                                <p>Най-често се използва <i>vector</i> за списъците, така добавянето на ново ребро става с константна сложност. Предимство на това представяне е малката памет - \(O(m)\) за запазване на графа, както и това, че можем директно да преглеждаме съседите на даден връх. Ако искаме да поддържаме и премахване на ребра или пък трябва да отговаряме на въпроси дали между два върха има ребро, е удачно вместо <i>vector</i> да използваме <i>set</i> или <i>unordered_set</i>.</p>
                            </li>
                            <li class="dashed-list text-format" style="text-indent: 0px">списък на ребрата
                                <p>Тук поддържаме списък на ребрата (обикновено в задачите с графи, точно така се въвеждат данните за графа - като списък от ребрата му) чрез масив \(edges\). Понеже за повечето алгоритми в графи трябва лесно да достъпим съседите на даден връх, към това представяне се добавят два помощни масива - \(prev\) и \(last\). Първият масив е с размерност броя ребра. Ако схематично имаме \(edges[i]=(u,v)\), то \(prev[i]\) съдържа индекса на предното ребро, което излиза от връх \(u\). Вторият масив \(last\) е с размерност броя върхове и \(last[v]\) е всъщност индекса на последното ребро, което излиза от връх \(v\) в списъка \(edges\). За да стане по-ясно е показан интерактивен пример за ориентиран граф и съответната информация, която се записва.</p>
                                <div class="graphExample9 row">
                                    <div class="col-sm text-center">
                                        <div class="row settings-panel"></div>
                                        <div class="graph-container">
                                            <svg class="graph" viewBox="0 0 300 300" style="height: 50vh; max-width: 100%"></svg>
                                        </div>
                                    </div>
                                    <div class="col-sm my-auto text-center">
                                        <button class="btn btn-primary mb-2 default">Начален пример</button>
                                        <div class="row justify-content">
                                            <div class="col-sm text-center my-auto">
                                                <table class="table table-dark table-bordered edge-list" style="width: auto; margin: auto auto 5% auto">
                                                </table>
                                            </div>
                                            <div class="col-sm text-center my-auto">
                                                <table class="table table-dark table-bordered last" style="width: auto; margin: auto">
                                                </table>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <p>Така всъщност това представяне наподобява предното - двата помощни масива всъщност ни помагат да пазим списъците от съседите, но този път списъците са "пръснати" в списъка на ребрата. Това представяне се използва изключително рядко, защото е малко по-трудно за писане и използване от по-стандартните. Затова, за да е напълно ясно всичко, ще покажем и код, който въвежда ориентиран граф и го записва, използвайки това представяне, след което се обхождат съседите на връх 1.</p>
                                <div id="edge-list" class="placeholder"></div>
                                <p>Един детайл, който се вижда, е, че в началото попълваме \(last\) масива с -1. Така можем да разпознаваме краят на списъка на всеки връх, защото за първото ребро, което въведем, \(prev\) ще е -1. Това ни позволява и лесното обхождане на съседите на даден връх - като се движим по \(prev\) връзките. Също може да се забележи, че не записваме началото на реброто в масива \(edges\), а само краищата. Така се лишаваме от възможността по индекс на ребро да знаем върха, от който излиза, но от друга страна обикновено ни трябва само да обхождаме съседите на даден връх. Затова ни е достатъчно да пазим само краищата на ребрата, а така спестяваме и малко памет. При неориентиран граф нещата са малко по-сложни. Най-лесно е да слагаме всяко ребро по два пъти - за всяка посока. Така при въвеждане на ребрата можем да викаме два пъти функцията за добавяне на ребро: \(add\_edge(x,y)\) и \(add\_edge(y,x)\), като останалата част от кода остава без промяна.</p>
                            </li>
                        </ul>
                        <p class="text-format">Последно ще направим едно сравнение между показаните представяния. На следната таблица е представена информация за време на построяване, памет и времева сложност за някои основни операции при различните представяния в неориентирани графи.</p>
                        <div class="table-responsive" style="margin-bottom: 2vh">
                            <table class="table table-hover table-dark table-bordered text-center" style="width: auto; margin: auto">
                                <thead>
                                    <tr>
                                        <th style="background: grey">Харектеристика\Представяне</th>
                                        <th style="background: grey">матрица на съседство</th>
                                        <th style="background: grey">списък на съседите</th>
                                        <th style="background: grey">списък на ребрата</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td style="background: grey">Време за построяване</td>
                                        <td class="align-middle">\(O(m)\)</td>
                                        <td class="align-middle">\(O(n+m)\)</td>
                                        <td class="align-middle">\(O(n+m)\)</td>
                                    </tr>
                                    <tr>
                                        <td style="background: grey">Памет</td>
                                        <td class="align-middle">\(n^2\)</td>
                                        <td class="align-middle">\(n+2m\)</td>
                                        <td class="align-middle">\(n+3m\)</td>
                                    </tr>
                                    <tr>
                                        <td style="background: grey">Добавяне на ребро</td>
                                        <td class="align-middle">\(O(1)\)</td>
                                        <td class="align-middle">\(O(1)\)</td>
                                        <td class="align-middle">\(O(1)\)</td>
                                    </tr>
                                    <tr>
                                        <td style="background: grey">Изтриване на ребро</td>
                                        <td class="align-middle">\(O(1)\)</td>
                                        <td class="align-middle">\(O(1)\)*</td>
                                        <td class="align-middle">\(O(\)брой съседи\()\)</td>
                                    </tr>
                                    <tr>
                                        <td style="background: grey">Проверка за ребро</td>
                                        <td class="align-middle">\(O(1)\)</td>
                                        <td class="align-middle">\(O(1)\)*</td>
                                        <td class="align-middle">\(O(1)\)*</td>
                                    </tr>
                                    <tr>
                                        <td style="background: grey">Обхождане на съседите на връх</td>
                                        <td class="align-middle">\(O(n)\)</td>
                                        <td class="align-middle">\(O(\)брой съседи\()\)</td>
                                        <td class="align-middle">\(O(\)брой съседи\()\)</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="text-format">Показаните сложности важат и при ориентирани графи, като единствено при тях намаля ползваната памет: за списъка на съседите - на \(n+m\), а за списъка на ребрата на - \(n+2m\). При списък на съседите са показани оптимални сложности за триене и търсене на ребра, които се постигат, ако се използва <i>unordered_set</i> за списъците, но тази константа е в средния случай (<a class="info">...</a><a class="info" style="display: none">в лошия случай може да стигне линейна сложност</a>). Освен това в този случай, константата за добавянe също няма да е чиста, както ако се използва <i>vector</i>. Аналогичен е и случая за търсене на ребро при списък на ребрата, където в този случай би било удачно да имаме допълнителен <i>unordered_set</i> само за ребрата.</p>
                        <p class="text-format">От таблицата се вижда, че най-добрите две представяния са първите две. Дори може да изглежда, че матрицата на съседство е най-добрата. На практика се работи най-вече с така наречените <i>разредени</i> графи. При тях ребрата не са от порядъка на \(n^2\), а на \(n\). Понеже тези графи могат да имат голям брой върхове, е неприложимо да се използва матрица на съседство с квадратна памет. Освен това в почти всички алгоритми е нужно бързо да се намират съседите на даден връх, което е бавна операция при матрицата на съседство. Затова като правило, ако имаме неголям брой върхове (например до 1000) и работим с графи, които имат ребра от порядъка на \(n^2\), тогава е по-добре да се използва матрица на съседство. Във всички останали случаи се ползва списък на съседите. Остана да кажем какъв е смисълът от третото представяне. Всъщност голямо предимство при тях идва от това, че те не използват някакви по-тежки структури от данни, а само масиви. На практика се оказва, че при списъка на съседите голяма част от забавянето се получава от работата на векторите. Затова много пъти, отново в <i>разредени</i> графи, е по-бързо да се използва списък на ребрата. Техен недостатък е малко по-голямата памет, от която се нуждаят. Освен това макар и те да обхождат съседите един след друг, скаченето в масива на ребрата е по-бавно, отколкото в един вектор със самите съседи. Затова те са по-добри от списъка на съседите при по-малък брой ребра.</p>
                        <p class="text-format">След подробното сравнение, заключението е, че в повечето случаи се ползва списък на съседите. Това е и представянето, с което обикновено ще показваме повечето алгоритми в графи. При графи с по-малък брой върхове, но много ребра се ползва матрица на съседство. Списък на ребрата, предвид малко по-сложното писане, се ползва изключително рядко, при сравнително <i>разредени</i> графи с много върхове, когато се опитваме да направим малка оптимизация на константата на даден алгоритъм.</p>
                    </div>
                </div>
            </div>
                
            <div id="footer-placeholder"></div>
        </div>
    </body>
</html>