<!DOCTYPE html>
<html>
    <head>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-Y8NQ36XMJS"></script>
		<script>
		  window.dataLayer = window.dataLayer || [];
		  function gtag(){dataLayer.push(arguments);}
		  gtag('js', new Date());

		  gtag('config', 'G-Y8NQ36XMJS');
		</script>
        
        <link rel="shortcut icon" href="/algo-site/images/favicon.ico">
        <link type="text/css" rel="stylesheet" href="/algo-site/libs/bootstrap/dist/css/bootstrap.min.css"  media="screen,projection"/>
        <link type="text/css" rel="stylesheet" href="/algo-site/styles/style.css"  media="screen,projection"/>
        <link type="text/css" rel="stylesheet" href="/algo-site/styles/lesson.css"  media="screen,projection"/>
        <link type="text/css" rel="stylesheet" href="/algo-site/libs/highlight/styles/github-dark.min.css">
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
        <script type="text/javascript" src="/algo-site/libs/jquery/dist/jquery.slim.min.js"></script>
        <script type="text/javascript" src="/algo-site/libs/jquery/dist/jquery.min.js"></script>
        <script type="text/javascript" src="/algo-site/libs/popper.js/dist/umd/popper.min.js"></script>
        <script type="text/javascript" src="/algo-site/libs/bootstrap/dist/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="/algo-site/libs/Snap.svg/dist/snap.svg-min.js"></script>
        <script id="MathJax-script" async src="/algo-site/libs/mathjax/es5/tex-chtml.js"></script>
        <script type="text/javascript" src="/algo-site/js/main.js"></script>
        <script type="text/javascript" src="/algo-site/js/graph_drawer.js"></script>
        <script type="text/javascript" src="/algo-site/js/graph_lessons/introduction.js"></script>
        <title>Увод в графите</title>
    </head>
    <body>
        <header>
            <div class="background"></div>
            <div id="nav-placeholder"></div>
            <nav aria-label="breadcrumb" class="unselectable">
                <ol class="breadcrumb">
                    <li class="breadcrumb-item" style="z-index:0"><a href="/algo-site/pages/graph_lessons.html" class="text-danger">Графи</a></li>
                    <li class="breadcrumb-item active" style="z-index:0" aria-current="page">Увод в графите</li>
                    <li class="ml-auto">Последна промяна: 06.09.2021</li>
                </ol>
            </nav>
        </header>
        
        <div class="wrapper" tabindex="-1">
            <div class="content">            
                <h1 align="center">Увод в графите</h1>

                <div class="lesson-part-position">
                    <button class="btn btn-secondary">1. Какво представляват графите?</button>
                    <div id="firstPart">
                        <p class="text-format">Най-просто казано това са някакви неща, между които има някакви връзки. Например маршрутна мрежа, където „нещата“ са градове, а тези „връзки“ са пътни връзки. Има множество други примери, които могат да се моделират по такъв начин (приятелства, йерархия във фирма, ...). Те представляват удобна абстракция, която е част от много състезателни задачи.</p>
                        <p class="text-format bold">Формално определение и стандартни означения: Граф \(G\) е наредена двойка от множество от елементи (наречени върхове) \(V\) и (мулти)множество от (не)наредени двойки (наречени ребра) \(E\) между тях. Накратко: \(G(V,E)\). Броят върхове обикновено се бележи с \(n\), а броят ребра с \(m\).</p>
                        <p class="text-format">Тази тема е много важна в състезателната (и практическата) информатика. Има разнообразни алгоритми, които могат да се прилагат в графи. Понятията в тази тема са изключително много, затова ще ги въвеждаме малко, по-малко, когато ни трябват. Тук ще покажем само за най-основните.</p>
                    </div>
                </div>
                <div class="lesson-part-position">
                    <button class="btn btn-secondary">2. Основни понятия в теорията на графите.</button>
                    <div id="secondPart">
                        <p class="text-format">Всеки граф трябва да има поне един връх. Възможно е множеството от ребрата да е празно. Такъв граф наричаме <i>празен граф</i>. Самите върхове обикновено номерираме последователно с числата \(1,2,...,n\). Първо ще поговорим за два основни вида графи, които се получават в зависимост от това дали ребрата в графа имат ориентация или не.</p>
                        <ul>
                            <svg class="graphExample1" width="25%" viewBox="0 0 300 300" style="float:right; margin-left: 2%"></svg>
                            <li class="dashed-list text-format" style="text-indent: 0px; margin-bottom: 2%">ориентирани – както казахме ребрата могат да представляват наредени двойки (при тях редът има значение), т.е. връзката има посока. Например ако графът моделира йерархията във фирма е важно дали връзката е шеф-подчинен или подчинен-шеф. Представяме пример за такъв граф. Тази „картинка“ с кръгчета и насочени отсечки е стандартен начин за изобразяване на граф от човек. Множеството от върховете е \(V=\{1,2,3,4,5\}\), а на ребрата - \(E=\{(1,2),(1,3),(1,4),(2,5),(3,5)\}\). Забележете, че за всяка двойка в множеството \(E\), на първо място седи върхът, от който излиза реброто, а на второ, върхът, в който влиза реброто. В случая графът може да моделира йерархията във фирма, като човекът под номер 1 е най-големият шеф, а например човекът под номер 5 има двама преки началници. Понеже графът е ориентиран, то би могло да съществува и реброто \((2,1) \ne (1,2)\). Но то няма смисъл, ако графът представя йерархията във фирма. Тогава може този граф да показва познанствата на хора (ако приемем, че познанството не е двустранно). Обърнете внимание, че един и същ граф може да изобразява различни неща.</li>
                            <svg class="graphExample2" width="25%" viewBox="0 0 300 300" style="clear: both; float:right; margin-left: 2%"></svg>
                            <li class="dashed-list text-format" style="text-indent: 0px">неориентирани – ребрата в тези графи са ненаредени двойки. Забележете, че тук отсечките са ненасочени. Множеството от върховете е отново \(V=\{1,2,3,4,5\}\), а \(E=\{\{1,2\},\{1,3\},\{1,4\},\{2,5\},\{3,5\}\}\). Начина, по който означаваме ребрата с двуелементни множества е коректен по отношение на смисъла, че няма ориентация, но не е често срещан. Обикновено (и за сходство с ориентирания случай) ребрата отново се означават с кръгли скоби, като се уточнява, че говорим за неориентиран граф. Така че пак ще запишем \(E=\{(1,2),(1,3),(2,4),(2,5),(3,5)\}\). Тук за двойките няма значение разположението на върховете, а само кои са.</li>
                        </ul>
                        <p class="text-format">Има и така наречените смесени графи, където имаме и ориентирани, и неориентирани ребра. Те се срещат доста рядко, така че обикновено боравим с ориентиран или неориентиран граф. Ще отбележим, че това е най-важното разделение при графи. За голяма част от алгоритмите има значение с какъв вид граф се работи. Някои алгоритми са приложими само за единия тип графи, други стават по-сложни.</p>
                        <svg class="graphExample3" width="15%" viewBox="0 0 300 300" style="float:right; margin-left: 2%"></svg>
                        <p class="text-format">Още един важен тип графи са мултиграфите. В определението ни за граф това присъства като възможност, защото е казано, че множеството \(E\) може да е мултимножество. Всъщност това е разликата с обикновените графи - при мултиграфите е възможно да имаме ребра, които на практика не могат да се различат по свързаните върхове. Ето пример за ориентиран мултиграф. Имаме три ребра \((1,2)\). Забележете, че множеството с върхове в определението е посочено само като множество, така че при върховете няма повторения, защото искаме да различаваме върховете по имената им.</p>
                        <p class="text-format bold">Определение: Степен на връх \(v\) в неориентиран граф наричаме броя на ребрата, които излизат от връх \(v\), и означаваме с \(d(v)\). Формално \(d(v)=|\{u \mid (v,u) \in E\}|\) \(=|\{u \mid (u,v) \in E\}|\). При ориентирани графи има две понятия за степен - полустепен на входа и полустепен на изхода. Полустепен на входа на връх \(v\) наричаме броя влизащи ребра във върха и означаваме с \(d^{-}(v)\), а полустепен на изхода наричаме броя излизащи ребра от върха и означаваме с \(d^{+}(v)\). Математически: \(d^{-}(v)=|\{u \mid (u,v) \in E\}|\) и \(d^{+}(v)=|\{u \mid (v,u) \in E\}|\). В случая на ориентиран граф е прието степента на връх да е сумата от двете полустепени, т.е. \(d(v)=d^{-}(v)+d^{+}(v)\).</p>
                        <p class="text-format">Това понятие на повечето места се ползва за определението <i>изолиран връх</i> - връх \(v\) е изолиран \(\iff d(v)=0\), т.е. такъв връх не е свързан с други върхове от графа. Тук е момента да кажем, че това определение за изолиран връх пропуска един случай, в който също е удачно да се счита върха за изолиран. В графите има специални ребра наречени <i>примки</i>. Едно ребро е примка, когато е от вида \((v,v)\), т.е. свързва един и същ връх. Ако един връх има само ребра, които са примки, то той продължава да не е свързан с другите върхове. Затова определението за изолиран връх, което ние ще ползваме е следното: връх \(v\) е изолиран \(\iff |\{u \ne v \mid (u,v) \in E \) или \( (v,u) \in E\}|=0\). Също така ще отбележим, че понятието за степен на връх в неориентиран граф не е много точно, ако в графа може да има примки. Поради ред причини, всяка примка се брои два пъти в степента на съответния връх (за двата си края), т.е. в този случай степента на връх \(v\) е \(d(v)=|\{u \ne v \mid (v,u) \in E\}|+\) \(2*|\{u=v \mid (v,u) \in E\}|\). За да се изяснят тези неща, е даден примерен неориентиран граф с две примки на връх 1 и една примка на връх 2, където за всеки връх е записана степента, като могат да се добавят нови ребра, а степените се обновяват автоматично.</p>
                        <div class="row">
                            <div class="col-sm text-center">
                                <svg class="graphExample4" viewBox="0 0 300 280" style="height: 50vh"></svg>
                            </div>
                            <div class="col-sm text-center my-auto">
                                <table class="table table-dark table-bordered degree" style="width: auto; margin: auto">
                                </table>
                            </div>
                        </div>
                        <p class="text-format">В много случаи един граф да е мултиграф и да има примки усложнява нещата и при много алгоритми се налагат специфични частни случаи. Затова в повечето задачи се работи с графи, които не са мултиграфи и нямат примки. Такива графи ще наричаме <i>прости</i>. Забележете, че като говорим за <i>прост</i> граф, може да става дума както за ориентиран, така и за неориентиран.</p>
                        <p class="text-format bold">Определение: Един граф \(G'(V',E')\) е подграф на \(G(V,E)\) \(\iff V' \subseteq V\) и \(E' \subseteq E\).</p>
                        <p class="text-format bold">Определение: Връх \(u\) е съседен на връх \(v\) в граф \(G \iff (v,u) \in E\). Казваме още, че връх \(v\) има за съсед връх \(u\). Забележете, че в общия случай ако \(u\) е съсед на \(v\), то обратното не е задължително изпълнено. Обаче ако \(G\) е неориентиран, тогава съседството е двустранно и казваме, че върховете \(u\) и \(v\) са съседни.</p>
                        <p class="text-format">Вече можем да дефинираме едни от основните понятия в графите - път и цикъл. Неформално казано, път образуваме като тръгнем от някой начален връх, отидем до съседен връх, после до негов съседен и т.н. докато спрем на някой връх. Имаме цикъл, когато спрем на началния връх. Ето и формалните определения:</p>
                        <p class="text-format bold">Определение: Път в граф наричаме алтернираща поредица от върхове и ребра: \(v_1, e_1, v_2, e_2, ..., e_k, v_{k+1}\), където за всяко \(1 \le i \le k: e_i=(v_i, v_{i+1})\). Един път представлява цикъл, когато \(v_1=v_{k+1}\). Броят ребра \(k\), които участват, се нарича дължина на пътя\цикъла. Възможно е път да е съставен само от един връх, така че минималната дължина на път е 0.</p>
                        <p class="text-format">Когато не сме в мултиграф, то два върха еднозначно определят реброто между тях. Затова обикновено, когато говорим за път, разглеждаме само последователността от върховете на пътя. Същото важи и за цикли в графи, които не са мултиграфи. Една важна разновидност е така наречените <i>прости пътища</i>. Път е <i>прост</i>, когато всички върхове, които участват в него са различни. От това следва, че и ребрата не се повтарят. Този вид пътища са много важни, защото имат повече свойства и освен това винаги са краен брой. Аналогично имаме и понятие <i>прост цикъл</i>. При тях ще задължим освен върховете да са различни (с изключение на началния и крайния) и всички ребра да са различни. Тук е задължително да включим и ребрата, защото в неориентиран граф при ребро \((1,2)\), цикълът \(1,2,1\) не се брои за <i>прост</i>, въпреки че не се повтарят върхове освен 1. Идеята на <i>простия цикъл</i> е да няма тривиални повторения, затова не броим минаването два пъти по едно и също неориентирано ребро за такъв цикъл. Следва интерактивен пример, където за зададени върхове се намира минимален по-дължина прост път, както и цикъл през началния връх.</p>
                        <div class="graphExample5">
                            <div class="row">
                                <div class="col-sm">
                                    <div class="form-group float-right">
                                        <input class="form-control col-3 col-md-2 beg" style="float: right" maxLength="1"/>
                                        <label for="beg" class="label-input" style="float: right">Начален връх:</label>
                                    </div>
                                    <div class="form-group float-right" style="clear: both">
                                        <input class="form-control col-3 col-md-2 end" style="float: right" maxLength="1"/>
                                        <label for="end" class="label-input" style="float: right">Краен връх:</label>
                                    </div>
                                    <button class="btn btn-primary find" style="clear: both; float: right; margin-bottom: 2%">Намери!</button>
                                    <p class="paths" style="text-align: right; clear: both; float: right"></p>
                                </div>
                                <div class="col-sm text-center">
                                    <svg class="graph" viewBox="0 0 300 300" style="height: 40vh"></svg>
                                </div>
                            </div>
                        </div>
                        <p class="text-format">Както казахме, <i>простите</i> пътища и цикли намират голямо приложение. Затова, когато говорим за пътища и цикли ще имаме предвид, че те са <i>прости</i> освен ако не е уточнено друго допълнително. В неориентиран граф, когато между два върха има път, казваме още, че те са свързани. Едно важно понятие, което ще трябва по-нататък:</p>
                        <p class="text-format bold">Определение: Неориентиран граф \(G\) наричаме свързан \(\iff\) всеки два върха са свързани.</p>
                        <p class="text-format">Всички досегашни примери за неориентирани графи, без този с изолирания връх, са на свързани графи. Ясно е, че ако граф с повече от един връх има изолиран връх, то той няма как да е свързан, защото от изолирания връх няма път до другите върхове.</p>
                        <svg class="graphExample6" width="25%" viewBox="0 0 300 300" style="clear: both; float:right; margin-left: 2%"></svg>
                        <p class="text-format">Последно ще разгледаме графи, които са много приложими на практика и често срещани в задачите с графи. Можем да добавим допълнителни описания за всяко ребро, например дължина, време и т.н. Такива графи наричаме <i>претеглени графи</i>. Формална дефиниция е, че добавяме теглова функция \(f_w: E \to W\), където \(W\) е множество от възможните стойности на теглата. Най-често се работи с естествени числа за тегла на ребрата. За показания пример, графът би бил записан така: \(G(V,E,f_w)\), където \(f_w\) е функция дефинирана само за следните стойности - \(f_w((1,2))=1,\) \(f_w((1,3))=2,\) \(f_w((1,4))=3,\) \(f_w((2,5))=1\) и \(f_w((3,5))=2\).</p>
                    </div>
                </div>

                <div class="lesson-part-position">
                    <button class="btn btn-secondary">3. Представяне в паметта.</button>
                    <div id="thirdPart">
                        <p class="text-format">Една от големите разлики в задачите с графи по информатика, в сравнение с тези по математика, е, че, обикновено, самите графи са дадени. Графичното представяне, макар да е много нагледно за хората, е крайно неудобно и нееднозначно за паметта на компютрите. Има разнообразни представяния, тук ще разгледаме най-приложимите от тях.</p>
                        <ul>
                            <li class="dashed-list text-format" style="text-indent: 0px; margin-bottom: 2%">матрица на съседство
                                <p>Това е едно от най-простите представяния и донякъде по традиция се започва с него, макар и следващото представяне да е най-популярното. Нека първо говорим за непретеглени <i>прости</i> графи. Както се вижда от името, самото представяне е всъщност една матрица с размери \(n\)x\(n\), обикновено се бележи с \(A\). Всяка клетка \(A[u][v]\) има стойност 1 или 0 в зависимост от това дали имаме ребро \((u,v)\) или не. Когато разглеждаме мултиграфи, то представянето се разширява и във всяка клетка се пише по колко ребра има между съответните два върха - матрицата вече не е задължително булева. Предоставен е пример, където на графа могат да се добавят ребра (включително мултиребра) и да се наблюдава матрицата му на съседство:</p>
                                <div class="row">
                                    <div class="col-sm text-center">
                                        <svg class="graphExample7" viewBox="0 0 300 280" style="height: 50vh"></svg>
                                    </div>
                                    <div class="col-sm text-center my-auto">
                                        <table class="table table-dark table-bordered matrix" style="width: auto; margin: auto">
                                        </table>
                                    </div>
                                </div>
                                <p>Когато се прави матрица на съседство на неориентиран граф, лесно може да се забележи, че тя е симетрична относно главния диагонал - точно защото ребрата са и в двете посоки. Освен това числата по главния диагонал обозначават примки. Това важи и за ориентираните графи. Матрицата на съседство може да се прилага и в претеглени графи. Тогава в клетките на матрицата се записват самите тегла на съответните ребра, като често няма тегло 0, и отново се използва нулата за липса на ребро.</p>
                                <p>Следва да кажем какви са предимствата на това представяне на графите. Едно от големите предимства, е че лесно се добавят и премахват ребра с константна сложност (<a class="info">...</a><a class="info" style="display: none">просто се достъпва и променя съответната клетка</a>). Друго предимство пак в тази връзка е, че с константна сложност може да се отговаря на въпроса дали между два върха има ребро. Това представяне има сериозни недостатъци, затова често се избягва. Паметта, която трябва, дори и при малко ребра, винаги е от порядъка на \(O(n^2)\). Докато много често графите имат ребра в порядъка само на \(O(n)\). Също съществен недостатък е, че ни трябва линейно време (спрямо броя върхове), за да намерим всичките съседи на даден връх.</p>
                            </li>
                            <li class="dashed-list text-format" style="text-indent: 0px; margin-bottom: 2%">списък на съседите
                                <p></p>
                            </li>
                            <li class="dashed-list text-format" style="text-indent: 0px">списък на ребрата
                                <p></p>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
                
            <div id="footer-placeholder"></div>
        </div>
    </body>
</html>