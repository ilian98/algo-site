<!DOCTYPE html>
<html>
    <head>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-Y8NQ36XMJS"></script>
		<script>
		  window.dataLayer = window.dataLayer || [];
		  function gtag(){dataLayer.push(arguments);}
		  gtag('js', new Date());

		  gtag('config', 'G-Y8NQ36XMJS');
		</script>
        
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
        
        <link rel="shortcut icon" href="/algo-site/images/favicon.ico">
        <link type="text/css" rel="stylesheet" href="/algo-site/node_modules/bootstrap/dist/css/bootstrap.min.css"  media="screen,projection"/>
        <link type="text/css" rel="stylesheet" href="/algo-site/styles/style.css"  media="screen,projection"/>
        <link type="text/css" rel="stylesheet" href="/algo-site/styles/lesson.css"  media="screen,projection"/>
        <link type="text/css" rel="stylesheet" href="/algo-site/styles/animation.css"  media="screen,projection"/>
        <link type="text/css" rel="stylesheet" href="/algo-site/node_modules/@highlightjs/cdn-assets/styles/github-dark.min.css">
        
        <script type="text/javascript" src="/algo-site/node_modules/jquery/dist/jquery.slim.min.js"></script>
        <script type="text/javascript" src="/algo-site/node_modules/jquery/dist/jquery.min.js"></script>
        <script type="text/javascript" src="/algo-site/node_modules/@popperjs/core/dist/umd/popper.min.js"></script>
        <script type="text/javascript" src="/algo-site/node_modules/bootstrap/dist/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="/algo-site/node_modules/snapsvg/dist/snap.svg-min.js"></script>
        <script src="/algo-site/js/mathjax-config.js">></script>
        <script id="MathJax-script" async src="/algo-site/node_modules/mathjax/es5/tex-chtml.js"></script>
        <script type="text/javascript" src="/algo-site/node_modules/@highlightjs/cdn-assets/highlight.min.js"></script>
        <script type="text/javascript" src="/algo-site/node_modules/opentype.js/dist/opentype.min.js"></script>
        <script type="text/javascript" src="/algo-site/js/main.js"></script>
        <script type="text/javascript" src="/algo-site/js/graph_drawer/graph.js"></script>
        <script type="text/javascript" src="/algo-site/js/graph_drawer/graph_positioning.js"></script>
        <script type="text/javascript" src="/algo-site/js/graph_drawer/graph_drawer.js"></script>
        <script type="text/javascript" src="/algo-site/js/graph_drawer/graph_controller.js"></script>
        <script type="text/javascript" src="/algo-site/js/dropdown.js"></script>
        <script type="text/javascript" src="/algo-site/js/animation.js"></script>
        <script type="text/javascript" src="/algo-site/js/graph_lessons/articulation_components.js"></script>
        <title>Артикулационни върхове и ребра</title>
    </head>
    <body>
        <header>
            <div id="nav-placeholder"></div>
            <nav aria-label="breadcrumb" class="unselectable">
                <ol class="breadcrumb">
                    <li class="breadcrumb-item">
                        <a href="/algo-site/pages/graph_lessons.html" class="link-danger">Графи</a>
                    </li>
                    <li class="breadcrumb-item">
                        <a class="link-secondary">Артикулационни върхове и ребра</a>
                    </li>
                    <li class="ms-auto">Последна промяна: 28.12.2021</li>
                </ol>
            </nav>
        </header>
        
        <div class="wrapper" tabindex="-1">
            <div class="content">            
                <h1 align="center">Артикулационни върхове и ребра</h1>
                
                <div class="lesson-part-position">
                    <button class="btn btn-secondary">1. Какво представляват артикулационните върхове и ребра?</button>
                    <div class="lesson-part">
                        <div>
                            <div class="graph-container" style="width: 20%; float: right; margin-left: 2vw">
                                <svg class="graphExample1" viewBox="0 0 300 300"></svg>
                            </div>
                            <p class="text-format">Тези понятия възникват единствено в неориентираните графи.</p>
                            <p class="text-format bold">Определение: Артикулационно ребро е такова ребро на графа, при чието премахване графът увеличава броя на свързаните си компоненти.</p>
                            <p class="text-format">Наричат се още <i>мостове</i>, поради житейската аналогия. Най-често в тази ситуация разглеждаме свързани графи, при които премахването на <i>мост</i>, прави графа несвързан (<a class="info">...</a><a class="info" style="display: none">с 2 компоненти на свързаност</a>). Графът от примера има само едно артикулационно ребро - $(3,4)$. По аналогичен начин се дефинира <i>артикулационен връх</i>.
                            <p class="text-format bold">Определение: Артикулационен връх е такъв връх на графа, при чието премахване (заедно с неговите ребра) графът увеличава броя на свързаните си компоненти.</p>
                            <p class="text-format">Наричат се още <i>артикулационни точки</i>.</p>
                        </div>
                        <div style="clear: both">
                            <div class="graph-container" style="width: 20%; float: right; margin-left: 2vw">
                                <svg class="graphExample2" viewBox="0 0 300 300"></svg>
                            </div>
                            <p class="text-format">Двете понятия имат някаква връзка помежду си. Нека имаме <i>артикулационното ребро</i> $(u,v)$. В повечето случаи поне един от краищата му $u$ и/или $v$ ще е <i>артикулационен връх</i>. Това означава, че от <i>мостовете</i> по принцип получаваме <i>артикулационни върхове</i>. Обратната посока - от <i>артикулационна точка</i> да следва <i>мост</i>, се случва по-рядко. Показан е пример, където връх 3 е <i>артикулационна точка</i>, но никое ребро не е <i>мост</i> - при премахването на което и да е ребро, графът остава свързан.</p>
                        </div>
                        <p class="text-format" style="clear: both">Оказва се, че тези специални компоненти на графа са полезни за изучаване. За самата свързаност на графа също е важно да се знае наличието на артикулационните върхове и ребра. В следващата точка ще разгледаме най-популярният и бърз алгоритъм за намирането им, а последно ще покажем едно тяхно приложение.</p>
                    </div>
                </div>

                <div class="lesson-part-position">
                    <button class="btn btn-secondary">2. Алгоритъм на Таржан</button>
                    <div class="lesson-part">
                        <p class="text-format">Първо ще опишем алгоритъма за намиране на <i>мостове</i>, а от там лесно се получава и алгоритъм за намиране на <i>артикулационните точки</i>. Понятието, което разгледахме, беше общо - дори и за несвързани графи. Ясно е, че за намиране на всички мостове трябва да разглеждаме всяка компонента на свързаност по отделно, така че нека БОО (<a class="info">...</a><a class="info" style="display: none">без ограничение на общността, т.е. можем да разсъждаваме аналогично и без приемането на този факт</a>) приемем, че графът е свързан. Често, когато сме в неориентирани графи е полезно да разгледаме покриващо дърво на графа. Такъв е и случаят сега. Както знаем от темата за дървета, при намиране на покриващо дърво, ребрата на оригиналния неориентиран граф се разделят на две групи - <i>дървесни ребра</i> и <i>обратни ребра</i>. Нека първо разгледаме <i>обратните ребра</i>. Лесно се вижда, че те няма как да са <i>мостове</i> - при премахването на кое и да е от тях, графът остава свързан, защото все още разпологаме с цялото покриващо дърво. Така получаваме, че единствено <i>дървесните ребра</i> са кандидати за мостове. От това следва, че мостовете на един свързан граф са най-много $n-1$, като при граф, който е дърво, се достига точно тази бройка.</p>
                        <p class="text-format">Сега остава да намерим хубаво условие за определяне дали дадено <i>дървесно ребро</i> $(x,y)$ е мост (да кажем, че $x$ е баща на $y$ в дървото). Нека си представим какво се случва, когато се премахне това ребро. Графът се разпада на потенциално две свързани компоненти - поддървото на връх $y$ и останалата част (всичко от връх $x$ нагоре и настрани). Ясно е, че поддървото си остава свързано, както и другата част остава свързана, заради наличието на останалите ребра от покриващото дърво. Така единствено трябва да установим дали двете части не остават свързани. Но тази свързаност може да се получи единствено от <i>обратно ребро</i>, насочено от поддървото на връх $y$ към горната част над $y$. Наистина, ако няма такова ребро, то няма как от поддървото да стигнем някъде по-нагоре от $y$. Така получаваме следното условие. Едно ребро $(x,y)$ е мост $\iff$ всички обратни ребра в поддървото на $y$ остават в това поддърво (не достигат връх $x$ и нагоре).</p>
                        <p class="text-format">Лесно можем за поддървото на връх $y$ да разберем дали обратните ребра остават в поддървото. Нека разгледаме $in$-времената на краищата на <i>обратните ребра</i>. Ако няма обратно ребро, така че края му да има $in$-време, по-малко от това на връх $y$, то всички <i>обратни ребра</i> остават в поддървото. Така ако намерим минималното $in$-време от краищата на <i>обратните ребра</i>, то реброто ще е мост ако тази стойност е $\ge$ от $in$-времето на $y$. В противен случай, имаме ребро, което се качва над $y$ и така със сигурност фиксираното ребро $(x,y)$ не е мост. По този начин можем да формулираме лесен линеен алгоритъм по графа за намиране на мостовете, който всъщност е открит за първи път от Таржан. Цялото намиране се осъществява с един <i>DFS</i>, в който едновременно строим покриващо дърво и извършваме малко допълнителна работа за откриване на мостовете. Поддържаме два допълнителни масива - $in$ и $up$, съответно за $in$-времената на върховете и за минималното $in$-време на връх в поддървото. За всеки връх $x$, стойността на $up[x]$ намираме като минимума от $in[x]$ и следните стойности от последователното обхождане на съседите на връх $x$:</p>
                        <ul style="margin-top: -10px">
                            <li class="dashed-list">за необходен съсед $y$ (т.е. край на <i>дървесно ребро</i>) гледаме $in[y]$</li>
                            <li class="dashed-list">за обходен съсед $y$, който не е бащата на върха (т.е. e начало или край на <i>обратно ребро</i>), гледаме $up[y]$</li>
                        </ul>
                        <p class="text-format">От вече казаното, <i>дървесното ребро</i> $(x,y)$ е мост $\iff$ $up[y] \ge in[y]$. Следва реализация на описания алгоритъм:</p>
                        <div id="bridges" class="placeholder"></div>
                        <div class="graphExample3 row" style="clear: both">
                            <div class="col-sm">
                                <p class="text-format">Тук е показан интерактивeн пример на алгоритъма. Анимацията се пуска с бутона "Старт", като може да зададете от кой връх да започва обхождането (и съответно да е корен на покриващото дървото). Преди да започне анимацията, графът се пренарежда, така че да съответства на покриващото дърво, като съответно <i>обратните ребра</i> са изобразени с пунктир. Също така, преди натискане на "Старт", може да задавате ускорение от 1 до 9, а по време на анимацията да превъртате на предишна или следваща стъпка.</p>
                                <div class="row">
                                    <div class="col-auto mb-2">
                                        <button class="btn btn-primary default">Начален пример</button>
                                    </div>
                                    <div class="col mb-2">
                                        <div class="row form-group">
                                            <label for="start-vertex" class="col-auto col-form-label pe-0 unselectable">Начален връх:</label>
                                            <div class="col-auto">
                                                <input class="form-control start-vertex" maxLength="1" style="width: 2.5rem; max-width: 100%"/>
                                            </div>
                                        </div>
                                    </div>
                                </div>                
                            </div>
                            
                            <div class="col-sm right-col">
                                <div class="row mb-2 settings-panel"></div>
                                <p class="time" style="text-align: center; margin-bottom: 0"></p>
                                <div class="row text-center">
                                    <div class="graph-container" style="margin: 0">
                                        <svg class="graph" viewBox="0 0 300 300" style="height: 60vh"></svg>
                                    </div>
                                </div>
                                <p class="anim-text"></p>

                                <div class="row mt-2 animation-panel"></div>
                            </div>
                        </div>
                        <p class="text-format">Описаният алгоритъм има един пропуск единствено, когато имаме мултиграф. Нека например разглеждаме граф, който се състои само от две мултиребра $(1,2)$ и коренът на покриващото дърво е връх 1. В този граф е ясно, че няма нито един <i>мост</i>, но алгоритъмът ще каже, че едно от двете ребра е мост. Това се получава, защото той приема, че когато види ребро на връх, което сочи баща му, то това ребро е <i>дървесно</i>, а при мултиграф това не е винаги вярно. Затова, когато приключим с връх 2, ще имаме $up[2]=in[2]$, а правилното е $up[2]=in[1]$ (<a class="info">...</a><a class="info" style="display: none">пропускаме да забележим едното ребро $(1,2)$, което се явява <i>обратно</i></a>). Най-добрият начин да отстраним този проблем е параметърът на <i>DFS</i>, който отразява бащата, да е всъщност номерът на <i>дървесното ребро</i> и така, като сме на връх 2 ще отчетем едното ребро, че е <i>обратно</i>, а другото, че е <i>дървесно</i>.</p>
                        <p class="text-format">Последно ще коментираме как намираме <i>артикулационните върхове</i> на граф, което е до голяма степен аналогично на <i>мостовете</i>. Отново това става с модификация на обхождането в дълбочина. Сега трябва да си представим какво става с графа, когато премахнем един връх $x$. Отново всичко, което е нагоре и настрани от $x$ е потенциална нова свързана компонента, като сега и всички поддървета на децата на $x$ са потенциални нови свързани компоненти. Заради свойствата на покриващото дърво, което се получава от <i>DFS</i>, то тези поддървета имат <i>обратни ребра</i>, които сочат нагоре, т.е. няма как да свързват поддърветата. Затова единственият шанс всичко да остане свързано е всяко поддърво да има <i>обратно ребро</i>, което да сочи нагоре от връх $x$. Ако приемем, че отново смятаме същите масиви $in$ и $up$ за всеки връх, то един връх $x$ е артикулационна точка $\iff$ има дете $y$, за което $up[y] \ge in[x]$. Ето код за този алгоритъм:</p>
                        <div id="articulation-points" class="placeholder"></div>
                        <p class="text-format">Може да бъде забелязан един частен случай - когато сме на корена. Проблемът с корена е, че досега логиката ни търсеше <i>обратни ребра</i>, които да отиват над текущия връх, за да са свързани с горната част, но при махането на коренът няма такава част. Лесно може да се види, че коренът е <i>артикулационна точка</i>, тогава и само тогава, когато има повече от едно дете. Това в програмата се проверява с $flag$ - за всяко дете на корена, нашата проверка за артикулационност е в сила (<a class="info">...</a><a class="info" style="display: none">$up[to] \ge 0 = in[vr]$ за корена $vr$</a>) и така реално се броят децата. Двата показани алгоритъма са със сложност $O(n+m)$.</p>
                    </div>
                </div>
                
                <div class="lesson-part-position">
                    <button class="btn btn-secondary">3. Двусвързани компоненти на граф</button>
                    <div class="lesson-part">
                        <p class="text-format">Първоначално говорихме, че един граф е свързан, ако всеки два върха в него са свързани. Това определение естествено може да се продължи, за да характеризира "по-силна" свързаност. Единият начин е да искаме върховете да останат свързани дори и точно един от върховете да бъдат изтрити.</p>
                        <p class="text-format bold">Определение: Граф наричаме двусвързан $\iff$ при премахването, на който и да е връх, всеки два от останалите върхове остават свързани.</p>
                        <p class="text-format">Очевидно, за да може един граф да е двусвързан, той първо трябва да е (едно)свързан. В контекста на свързаност говорим за свързани компоненти. Тук аналогично можем да говорим за <i>двусвързани компоненти</i>, макар и да нямаме точно разпадане на компоненти.</p>
                        <p class="text-format bold">Определение: Двусвързани компоненти на граф наричаме максималните по включване подграфи на началния граф, така че всеки подграф да е двусвързан.</p>
                        <div class="graph-container" style="width: 20%; float: right; margin-left: 2vw">
                            <svg class="graphExample4" viewBox="0 0 300 300"></svg>
                        </div>
                        <p class="text-format">Проблемът е, че за разлика от <i>свързаните компоненти</i>, които нямат общо помежду си, то <i>двусвързаните</i> могат да имат по един общ връх. Лесно може да се покаже, че всъщност общите върхове са точно <i>артикулационните точки</i> на графа. Показан е началният пример, в който са оцветени компонентите в пурпурен и жълт цвят, а общият връх (<i>артикулационна точка</i>) е в смесения цвят на двата - червен. Самото разбиване има хубави свойства. По аналогия на ССК (<a class="info">...</a><a class="info" style="display: none">вижте първо урока за силно свързани компоненти</a>) можем да направим кондензиран граф с върхове тези компоненти, както и по един връх за всяка <i>артикулационна точка</i>, а ребрата са между връх на кондензирана <i>двусвързана компонента</i> и връх за <i>артикулационна точка</i> от тази компонента. Полученият кондензиран граф всъщност винаги е дърво. За нашето разглеждане, по-важни са друг вид подобни на <i>двусвързаните компоненти</i>, които ще разглеждаме в малко по-големи детайли в следващите абзаци.</p>
                        <p class="text-format">Започнахме разглеждането с това, че единият начин да усилим свързаността, е като искаме свързаност при премахването на един връх. Вторият начин е ако искаме свързаност при махането, на което и да е ребро. Така имаме аналогични понятия на предните:</p>
                        <p class="text-format bold" style="margin-top: -10px">Определения:</p>
                        <ul style="margin-top: -10px">
                            <li class="dashed-list bold">Граф наричаме двойно свързан $\iff$ при премахването, на което и да е ребро, всеки два от върховете остават свързани.</li>
                            <li class="dashed-list bold">Двойно свързани компоненти на граф наричаме максималните по включване подграфи на началния граф, така че всеки подграф да е двойно свързан.</li>
                        </ul>
                        <div class="graphExample5 row" style="clear: both">
                            <div class="col-sm">
                                <p class="text-format">Отново, за да може един граф да е двойно свързан, трябва да е поне свързан. По аналогия със съкращението ССК, тези компоненти ще наричаме ДСК (Двойно Свързани Компоненти) (<a class="info">...</a><a class="info" style="display: none">тук ще уточним, че на английски се използват малко по-различни наименования - 2-edge-connected graph и 2-edge-connected components; с цел по-кратко и приятно наименование и разлика с двусвързаните, ще ги наричаме двойно свързани</a>). При тези компоненти имаме хубавото разпадане, при което те нямат общи върхове и ребра. Всъщност ДСК се получават и много по-лесно. Достатъчно е първо да намерим всички <i>мостове</i> на графа, след което да премахнем намерените <i>мостове</i>. Така получените <i>свързани компоненти</i> са всъщност <i>двойно свързаните</i> на оригиналния граф. Лесно се вижда, че това е така - ако премахнем някое ребро от тези компоненти, то те остават свързани, защото иначе махнатото ребро би било <i>мост</i>, а ние махнахме всички <i>мостове</i>, за да ги образуваме. Показан е интерактивен пример, за който двойно свързаните компоненти се поддържат оцветени, както и <i>мостовете</i>.</p>
                            </div>
                            
                            <div class="col-sm right-col">
                                <div class="row mb-2 settings-panel"></div>
                                <div class="row text-center">
                                    <div class="graph-container" style="margin: 0">
                                        <svg class="graph" viewBox="0 0 300 300" style="height: 60vh"></svg>
                                    </div>
                                </div>
                                
                                <div class="row justify-content-center mt-2">
                                    <div class="col-auto">
                                        <button class="btn btn-primary default" style="float: right">Начален пример</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <p class="text-format">Самите <i>двойно свързани компенти</i> са свързани чрез <i>мостовете</i> на графа. Тук директно можем да кондензираме компонентите и отново кондензирания граф се получава дърво, който факт лесно може да се докаже. Последно, ще кажем един полезен факт за <i>двойно свързаните компоненти</i> - за всеки два върха в една двойно свързана компонента има поне два прости пътя между тях без общи ребра. Понеже графът е неориентиран, това означава, че и всеки два върха в ДСК участват в прост цикъл. Това свойство е много силно, защото лесно се вижда, че то е и достатъчно условие дадена компонента да е <i>двойно свързана</i>.</p>
                    </div>
                </div>

            </div>
            
            <div id="footer-placeholder"></div>
        </div>
    </body>
</html>