<!DOCTYPE html>
<html>
    <head>
        <link type="text/css" rel="stylesheet" href="/algo-site/libs/bootstrap/dist/css/bootstrap.min.css"  media="screen,projection"/>
        <link type="text/css" rel="stylesheet" href="/algo-site/styles/style.css"  media="screen,projection"/>
        <link type="text/css" rel="stylesheet" href="/algo-site/styles/lesson.css"  media="screen,projection"/>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
        <script type="text/javascript" src="/algo-site/libs/jquery/dist/jquery.slim.min.js"></script>
        <script type="text/javascript" src="/algo-site/libs/jquery/dist/jquery.min.js"></script>
        <script type="text/javascript" src="/algo-site/libs/popper.js/dist/umd/popper.min.js"></script>
        <script type="text/javascript" src="/algo-site/libs/bootstrap/dist/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="/algo-site/libs/Snap.svg/dist/snap.svg-min.js"></script>
        <script id="MathJax-script" async src="/algo-site/libs/mathjax/es5/tex-chtml.js"></script>
        <script type="text/javascript" src="/algo-site/js/main.js"></script>
        <script type="text/javascript" src="/algo-site/js/ds_tree_lessons/segment_trees/segment_tree_introduction.js"></script>
        <script type="text/javascript" src="/algo-site/js/graph_drawer.js"></script>
        <script type="text/javascript" src="/algo-site/js/animation.js"></script>
        <title>Увод в сегментните дървета</title>
    </head>
    <body>
        <header>
            <div class="background"></div>
            <div id="nav-placeholder"></div>
            <nav aria-label="breadcrumb" class="unselectable">
                <ol class="breadcrumb">
                    <li class="breadcrumb-item" style="z-index:0">
                        <a href="/algo-site/pages/ds_tree_lessons.html" class="text-danger">Структури от данни</a>
                    </li>
                    <li class="breadcrumb-item" style="z-index:0">
                        <a href="#" class="text-danger">Сегментни дървета</a>
                    </li>
                    <li class="breadcrumb-item active" style="z-index:0" aria-current="page">Увод</li>
                    <li class="ml-auto">Последна промяна: 29.04.2021</li>
                </ol>
            </nav>
        </header>
        
        
        <div class="wrapper">
            <div class="content">            
                <h1 align="center">Увод в сегментните дървета</h1>

                <div class="lesson-part-position">
                    <button class="btn btn-secondary">1. За какво се използват?</button>
                    <div id="firstPart">
                        <p class="text-format">Това е една от най-използваните и гъвкави структури от данни в състезателната информатика. Обикновено сегментното дърво се построява върху някакъв масив и поддържа бързо два типа заявки - за намиране на някаква информация за подмасив (така наречените заявки за търсене) и за промяна на един елемент или подмасив (заявки за обновяване). Много често се среща в задачи със заявки. В по-сложни задачи понякога част от задачата се свежда до някакви заявки и съответно за тях се използва сегментно дърво за бърза работа. Един минус, който имат е, че като цяло не могат да се поддържат добавяне на елемент или премахване освен в редки случаи. Така че обикновено си мислим за масива като с фиксиран брой елементи, който не се променя по време на заявките.</p>
                    </div>
                </div>

                <div class="lesson-part-position">
                    <button class="btn btn-secondary">2. Построяване на сегментно дърво</button>
                    <div id="secondPart">
                        <p class="text-format">Сегментното дърво е двоично кореново дърво (<a class="info">...</a><a class="info" style="display: none">за повече разбиране на тези понятия, вижте темата за дървета в графи</a>). Всеки връх на сегментното дърво отговаря за някакъв <i>сегмент</i> от масива, като сегментите на различни върхове в едно ниво не се пресичат. Затова се наричат и сегментни дървета :) Листата на дървото отговарят за единични сегменти - различните елементи на масива. Това, което се пази за всеки връх, винаги е свързано с конкретната цел, заради която построяваме сегментното. Така че, за да покажем как се построява и какво се пази във върховете, ще разгледаме следната стандартна задача. Нека имаме масив \(A\) от \(n\) числа. Заявките, които искаме да обработваме са следните:</p>
                        <ul style="margin-top: -10px">
                            <li class="dashed-list">заявки за търсене с параметри \(l\) и \(r\) - сумата на подмасив \(\sum\limits_{i=l}^r A[i]\)</li>
                            <li class="dashed-list">заявки за обновяване с параметри \(pos\) и \(val\) - променяме стойността на някой елемент \(A[pos]=val\)</li>
                        </ul>
                        <p class="text-format">Може да разгледате интерактивния пример, където е построено сегментно дърво по масив, по него ще обясним цялостната концепция.</p>
                        <div class="segTreeExample1 row">
                            <div class="form-group col-lg-5">
                                <form>
                                    <label for="array" class="label-input" style="float: left">Масив:</label>
                                    <input class="form-control col-9 col-md-6 col-lg-9 array" maxLength="47"/>
                                </form><br>
                                <button class="btn btn-primary make">Направи дървото!</button><br>
                                <button class="btn btn-primary default" style="margin-top: 2%">Върни началния пример</button>
                                <button class="btn btn-primary indexes" style="margin-top: 2%">Покажи номерата</button>
                            </div>
                            <div class="treeExample col-lg-7">
                                <svg class="graph" width="100%" viewBox="0 0 300 150" style="margin-top: 2%" onmousedown="return false"></svg>
                                <svg class="svg-save" width="100" height="100" viewBox="0 0 300 150"></svg>
                                <button class="btn btn-primary save" style="float: right">
                                    <svg class="bi" width="24px" height="24px" fill="currentColor">
                                        <use xlink:href="/algo-site/libs/bootstrap-icons/bootstrap-icons.svg#download"/>
                                    </svg>
                                </button>
                                <canvas class="canvas-save"></canvas>
                            </div>
                        </div>
                        <p class="text-format">В сегментното дърво всеки връх освен листата има по две деца. Коренът отговаря за целия масив (в нашия случай за числата на позиции от 1 до 8). Съответно лявото му дете отговаря за лявата половина от числата (тези на позиции от 1 до 4), а дясното дете - за дясната половина (от 5 до 8). Така рекурсивно ще стигнем до листата.  Сегментното дърво е рекурсивна структура от данни. На най-високо ниво, се използва идеята <i>разделяй и владей</i> върху дадения масив - ако връх отговаря за интервала \([l;r]\), то децата му отговарят за двете половинки \([l; {l+r \over 2}]\) и \([{l+r \over 2}+1; r]\), рекурсивно същото е за децата и техните деца и т.н. (това е <i>разделяй</i> частта). По-късно ще се убедим, че информацията за всеки връх, който не е листо, се получава от децата му - <i>владей</i> частта. Обикновено сегментното дърво се пази в един масив. Нека засега си мислим, че големината на масива е степен на двойката (за примера \(8=2^3\)). Ако означим с \(n\) броя числа в масива, то нека \(n=2^s\). Тогава лесно можем да сметнем общия брой върхове, които ще имаме в дървото - \(1+2^1+2^2+...+2^s=\) \(2^{s+1}-1=2n-1\). Това означава, че броя върхове, който ни трябва е линеен спрямо големината на масива.</p>
                        <p class="text-format">Нека номерираме върховете отгоре-надолу по нива и отляво-надясно, като започнем с номер 1 при корена. С бутона "Покажи номерата" може да се види тази номерация на примера. Наблюдателните могат да забележат следната зависимост за номерата на връх и неговите деца. Ако върхът е с номер \(k\), то лявото му дете е с номер \(2k\), а дясното - \(2k+1\). Затова се използва масив за запазване на сегментното дърво, защото лесно можем по номер на връх да се ориентираме за номерата на децата. Обратното, ако имаме връх с номер \(k\), то баща му е с номер \([{x\over 2}]\).</p>
                        <p class="text-format">Досега говорехме, че \(n\) е степен на двойката. Какво правим в общия случай? Един лесен начин е да допълним масива до най-близката степен на двойката с нули. Това обаче е напълно излишно. Може да се забележи, че ако използваме същата зависимост за позициите на връх и неговите деца, няма да имаме проблеми. Единствено в последното ниво (това на листата) може да имаме дупки в номерацията, т.е. номера, на които не съответстват връхове. Но ако винаги ползваме рекурсивната дефиниция,  това няма да създава проблеми. За да е по-ясно, вижте номерацията на върховете при сегментното дърво построено за 10 елемента, например. Един важен детайл е за броя върхове, които могат да ни трябват. Ако \(n=2^s+4\), може да се види, че спазвайки номерацията, максималния номер, който ще ни трябва ще е \(2^{s+1}+2^s+2^{s-1}+1=\) \((2n-8)+(n-4)+(n/2-2)+1=\) \(3n+n/2-13>3n\). Както казахме, ако \(n\) не е степен на двойката, последното ниво не е пълно. Ако най-близката \(\ge\) степен  на двойката e \(2^s \le 2n\), то за да направим оценка за максималния брой върхове, можем да мислим, че го построяваме върху масив с \(2^s\) елемента. Такова дърво би имало най-много \(2.2^s-1 \lt 4n\) елемента. Затова обикновено в задачи, когато има максимално ограничение \(MAXN\) за големината на масива с числата, за да няма големи разсъждения сегментното дърво се прави с големина \(4.MAXN\). От сега нататък вече не налагаме ограничение за големината на масива \(n\).</p>
                        <p class="text-format">Нека означим масива за сегментното дърво с \(tree\). Понеже разглеждаме сегментно дърво, което ще отговаря заявки за сума, то в масива за всеки връх ще пазим сумата на числата в масива, за които отговаря (<a class="info">...</a><a class="info" style="display: none">това са и записаните числа във върховете на дървото на интерактивния пример</a>). При листата, тази стойност отговаря само за едно число. Нека сме на връх с номер \(k\). Съответно лявото дете, което съдържа сумата на числата в лявата половина, ще е с номер \(2k\), а дясното дете, което отговаря за сумата на дясната половина - \(2k+1\). Тогава имаме следната лесна формула, за да сметнем стойността за върха \(k\) - \(tree[k]=tree[2k]+tree[2k+1]\). Това ни дава два лесни начина да построим сегментно дърво. Първият е итеративен - започваме да попълваме върховете в ред обратен на номерацията. По този начин, когато стигнем връх вече ще сме попълнили стойностите на децата му и ще можем по формулата да сметнем стойността му. Вторият начин, който ще покажем, е рекурсивен и следва рекурсивната дефиниция на структурата от данни:</p>
                        <div id="build-tree"></div>
                        <script> $.get("/algo-site/pages/ds_tree_lessons/segment_trees/build-tree.html", function (data) {
                                $("#build-tree").replaceWith(data);
                                });
                        </script>
                        <p class="text-format">Лесно се вижда, че функцията <i>build_tree</i> работи толкова пъти, колкото върхове има в сегментното дърво. Понеже броят на върховете е линеен относно големината на масива, то сложността, с която е построяването е линейна - \(O(n)\).</p>
                    </div>
                </div>

                <div class="lesson-part-position">
                    <button class="btn btn-secondary">3. Обработка на заявки</button>
                    <div id="thirdPart">
                        <p class="text-format">Както казахме по-рано има два основни типа заявки - за търсене и за промяна. Първо ще разгледаме тези, които се поддържат по-лесно и, които са един от големите плюсове на сегментното. Продължаваме да мислим за същата задача за поддържане на сума и променя на елемент.</p>
                        <ul style="margin-top: -10px">
                            <li class="dashed-list">заявки за обновяване с параметри \(pos\) и \(val\) - променяме стойността на някой елемент \(A[pos]=val\)</li>
                        </ul>
                        <p class="text-format">Нека помислим какво трябва да се промени след като \(A[pos]=val\). Промяна настъпва при тези върхове на сегментното, които отговарят за сегмент, съдържащ позиция \(pos\). Понеже интервалите на различните върхове от едно ниво не се пресичат, то тези върхове, където нещо трябва да се промени, са най-много колкото броя нива на дървото. Нещо, което досега не сме изяснили е колко са нивата. Понеже върховете във всяко следващо ниво нарастват двойно спрямо предходното (като изключим евентуално най-последното), то е ясно, че нивата са около \(\log_{2}n\), т.е. малък брой върхове се променят. Оказва се, че има лесен начин да опишем променящите се върхове - това са всички върхове по пътя от корена до листото, отговарящо за интервала \([pos; pos]\).</p>
                        <p class="text-format">Самата промяна, която настъпва е следната - отново трябва да изчислим сумата за всеки връх. Така ако оправяме стойностите отдолу-нагоре е достатъчно отново да сумираме за всеки връх, стойностите на лявото и дясното дете за правилна сума. Отново има два начина да реализираме това - итеративен и рекурсивен. Итеративният начин започва от листото и се движи нагоре по бащите. За този начин трябва да запазим позицията на всяко листо, а катеренето нагоре по бащите е просто с целочислено делене на 2. Ние ще покажем рекурсивния начин, защото той е по-лесен за писане (макар и малко по-бавен) и по-полезен за бъдещите надграждания на сегментното дърво.</p>
                        <div id="update-tree"></div>
                        <script> $.get("/algo-site/pages/ds_tree_lessons/segment_trees/update-tree.html", function (data) {
                                $("#update-tree").replaceWith(data);
                                });
                        </script>
                        <p class="text-format">На всяка стъпка на рекурсията проверяваме дали листото, отговарящо за променения елемент е вляво или вдясно. А на обратния ход - смятаме наново сумата за всеки връх, през който сме минали, за да отразим променения елемент. След тази функция всички върхове на сегметното дърво имат правилна стойност след промяната. Ясно е, че функцията работи колкото елемента се променят, т.е. със сложност \(O(\log_{2}n)\). За по-добро разбиране е предоставен интерактивен пример на работата на рекурсията при заявка за промяна.</p>
                        <div class="segTreeExample2 row">
                            <div class="form-group col-lg-5">
                                <form>
                                    <label for="array" class="label-input" style="float: left">Масив:</label>
                                    <input class="form-control col-9 col-md-6 col-lg-9 array" maxLength="47"/>
                                </form><br>
                                <button class="btn btn-primary make">Направи дървото!</button><br>
                                <button class="btn btn-primary default" style="margin-top: 2%">Върни началния масив</button>
                                <form style="margin-top: 5%">
                                    <label for="array" class="label-input" style="float: left">\(pos=\)</label>
                                    <input class="form-control col-2 col-md-1 col-lg-2 pos" style="float: left" maxLength="2"/>
                                    <label for="array" class="label-input" style="float: left; margin-left: 2%">\(val=\)</label>
                                    <input class="form-control col-2 col-md-1 col-lg-2 val" style="float: left" maxLength="2"/>
                                </form><br><br>
                            </div>
                            <div class="treeExample col-lg-7">
                                <button class="btn btn-primary start">Старт!</button>
                                <button class="btn btn-primary end">Край</button>
                                <button class="btn btn-primary next" style="margin-left: 1%; float: right">
                                    <svg class="bi" width="24px" height="24px" fill="currentColor">
                                        <use xlink:href="/algo-site/libs/bootstrap-icons/bootstrap-icons.svg#skip-end-fill"/>
                                    </svg>
                                </button>
                                <button class="btn btn-primary previous" style="margin-left: 3%; float: right">
                                    <svg class="bi" width="24px" height="24px" fill="currentColor">
                                        <use xlink:href="/algo-site/libs/bootstrap-icons/bootstrap-icons.svg#skip-start-fill"/>
                                    </svg>
                                </button>
                                <button class="btn btn-primary pause" style="float: right">Пауза</button>
                                
                                <svg class="graph" width="100%" viewBox="0 0 300 150" style="margin-top: 2%" onmousedown="return false"></svg>
                                <svg class="svg-save" width="100" height="100" viewBox="0 0 300 150"></svg>
                                <button class="btn btn-primary save" style="float: right">
                                    <svg class="bi" width="24px" height="24px" fill="currentColor">
                                        <use xlink:href="/algo-site/libs/bootstrap-icons/bootstrap-icons.svg#download"/>
                                    </svg>
                                </button>
                                
                                
                                <div class="form-group">
                                    <label for="duration" style="float: left" class="label-input">Ускорение:</label>
                                    <input class="form-control col-2 speed" style="float: left" maxLength="1" onkeypress="return isDigit(event)"/>
                                </div>
                                <p class="anim-text"></p>
                                <canvas class="canvas-save"></canvas>
                            </div>
                        </div>
                        
                        
                        <ul>
                            <li class="dashed-list">заявки за търсене с параметри \(l\) и \(r\) - сумата на подмасив \(\sum\limits_{i=l}^r A[i]\)</li>
                        </ul>
                        
                    </div>
                </div>

                <div class="lesson-part-position">
                    <button class="btn btn-secondary">4. Динамични сегментни дървета</button>
                    <div id="fourthPart">

                    </div>
                </div>
            </div>
            
            <div id="footer-placeholder"></div>
        </div>
        
        
    </body>
</html>