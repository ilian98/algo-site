<!DOCTYPE html>
<html>
    <head>
        <link type="text/css" rel="stylesheet" href="/algo-site/libs/bootstrap/dist/css/bootstrap.min.css"  media="screen,projection"/>
        <link type="text/css" rel="stylesheet" href="/algo-site/styles/style.css"  media="screen,projection"/>
        <link type="text/css" rel="stylesheet" href="/algo-site/styles/lesson.css"  media="screen,projection"/>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
        <script type="text/javascript" src="/algo-site/libs/jquery/dist/jquery.slim.min.js"></script>
        <script type="text/javascript" src="/algo-site/libs/jquery/dist/jquery.min.js"></script>
        <script type="text/javascript" src="/algo-site/libs/popper.js/dist/umd/popper.min.js"></script>
        <script type="text/javascript" src="/algo-site/libs/bootstrap/dist/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="/algo-site/libs/Snap.svg/dist/snap.svg-min.js"></script>
        <script id="MathJax-script" async src="/algo-site/libs/mathjax/es5/tex-chtml.js"></script>
        <script type="text/javascript" src="/algo-site/js/main.js"></script>
        <script type="text/javascript" src="/algo-site/js/graph_drawer.js"></script>
        <script type="text/javascript" src="/algo-site/js/ds_tree_lessons/segment_trees/segment_tree_introduction.js"></script>
        <title>Увод в сегментните дървета</title>
    </head>
    <body>
        <header>
            <div class="background"></div>
            <div id="nav-placeholder"></div>
            <nav aria-label="breadcrumb" class="unselectable">
                <ol class="breadcrumb">
                    <li class="breadcrumb-item" style="z-index:0">
                        <a href="/algo-site/pages/ds_tree_lessons.html" class="text-danger">Структури от данни</a>
                    </li>
                    <li class="breadcrumb-item" style="z-index:0">
                        <a href="#" class="text-danger">Сегментни дървета</a>
                    </li>
                    <li class="breadcrumb-item active" style="z-index:0" aria-current="page">Увод</li>
                    <li class="ml-auto">Последна промяна: 29.04.2021</li>
                </ol>
            </nav>
        </header>
        
        
        <div class="wrapper">
            <div class="content">            
                <h1 align="center">Увод в сегментните дървета</h1>

                <div class="lesson-part-position">
                    <button class="btn btn-secondary" onclick="toggleText('firstPart')">1. За какво се използват?</button>
                    <div id="firstPart">
                        <p class="text-format">Това е една от най-използваните и гъвкави структури от данни в състезателната информатика. Обикновено сегментното дърво се построява върху някакъв масив и поддържа бързо два типа заявки - за намиране на някаква информация за подмасив (така наречените заявки за търсене) и за промяна на един елемент или подмасив (заявки за обновяване). Много често се среща в задачи със заявки. В по-сложни задачи понякога част от задачата се свежда до някакви заявки и съответно за тях се използва сегментно дърво за бърза работа. Един минус, който имат е, че като цяло не могат да се поддържат добавяне на елемент или премахване освен в редки случаи. Така че обикновено си мислим за масива като с фиксиран брой елементи, който не се променя по време на заявките.</p>
                    </div>
                </div>

                <div class="lesson-part-position">
                    <button class="btn btn-secondary" onclick="toggleText('secondPart'); initExamples(2)">2. Построяване на сегментно дърво</button>
                    <div id="secondPart">
                        <p class="text-format">Сегментното дърво е двоично кореново дърво (<a class="info" onclick="triggerInfo(1)" id="trigger1">...</a><a class="info" onclick="triggerInfo(1)" id="info1" style="display: none">за повече разбиране на тези понятия, вижте темата за дървета в графи</a>). Всеки връх на сегментното дърво отговаря за някакъв <i>сегмент</i> от масива, като сегментите на различни върхове не се пресичат. Затова се наричат и сегментни дървета :) Листата на дървото отговарят за единични сегменти - различните елементи на масива. Това, което се пази за всеки връх, винаги е свързано с конкретната цел, заради която построяваме сегментното. Така че, за да покажем как се построява и какво се пази във върховете, ще разгледаме следната стандартна задача. Нека имаме масив \(A\) от \(n\) числа. Заявките, които искаме да обработваме са следните:</p>
                        <ul style="margin-top: -10px">
                            <li class="dashed-list">заявки за търсене с параметри \(l\) и \(r\) - сумата на подмасив \(\sum\limits_{i=l}^r A[i]\)</li>
                            <li class="dashed-list">заявки за обновяване с параметри \(pos\) и \(val\) - променяме стойността на някой елемент \(A[pos]=val\)</li>
                        </ul>
                        <p class="text-format">Може да разгледате интерактивния пример, където е построено сегментно дърво по масив, по него ще обясним цялостната концепция.</p>
                        <div class="segTreeExample1 row">
                            <div class="form-group col-lg-5">
                                <form>
                                    <label for="array" class="label-input" style="float: left">Масив:</label>
                                    <input class="form-control col-9 col-md-6 col-lg-9 array" maxLength="47"/>
                                </form><br>
                                <button class="btn btn-primary make" onclick="makeSegTree(1)">Направи дървото!</button><br>
                                <button class="btn btn-primary default" onclick="defaultExample()" style="margin-top: 2%">Върни началния пример</button>
                                <button class="btn btn-primary default" id="index-btn" onclick="indexes()" style="margin-top: 2%">Покажи номерата</button>
                            </div>
                            <div class="treeExample col-lg-7">
                                <svg class="graph" width="100%" viewBox="0 0 300 150" style="margin-top: 2%" onmousedown="return false"></svg>
                                <svg class="svg-save" width="100" height="100" viewBox="0 0 300 150" style="margin-top: 2%"></svg>
                                <button class="btn btn-primary save" style="float: right">
                                    <svg class="bi" width="24px" height="24px" fill="currentColor">
                                        <use xlink:href="/algo-site/libs/bootstrap-icons/bootstrap-icons.svg#download"/>
                                    </svg>
                                </button>
                                <canvas class="canvas-save"></canvas>
                            </div>
                        </div>
                        <p class="text-format">В сегментното дърво всеки връх освен листата има по две деца. Коренът отговаря за целия масив (в нашия случай за числата на позиции от 1 до 8). Съответно лявото му дете отговаря за лявата половина от числата (тези на позиции от 1 до 4), а дясното дете - за дясната половина (от 5 до 8). Така рекурсивно ще стигнем до листата. Сегментното дърво е рекурсивна структура от данни. Обикновено то се пази в един масив. Нека засега си мислим, че големината на масива е степен на двойката (за примера \(8=2^3\)). В общия случай, ако \(n\) е броя числа в масива, то означаваме \(n=2^s\). Тогава лесно можем да сметнем общия брой върхове, които ще имаме в дървото - \(1+2^1+2^2+...+2^s=\) \(2^{s+1}-1=2n-1\). Това означава, че броя върхове, който ни трябва е линеен спрямо големината на масива.</p>
                        <p class="text-format">Нека номерираме върховете отгоре-надолу по нива и отляво-надясно, като започнем с номер 1 при корена. С бутона "Покажи номерата" може да се види тази номерация на примера. Наблюдателните могат да забележат следната зависимост за номерата на връх и неговите деца. Ако върхът е с номер \(k\), то лявото му дете е с номер \(2k\), а дясното - \(2k+1\). Затова се използва масив за запазване на сегментното дърво, защото лесно можем по номер на връх да се ориентираме за номерата на децата. Обратното, ако имаме връх с номер \(k\), то баща му е с номер \([{x\over 2}]\).</p>
                        <p class="text-format">Досега говорехме, че \(n\) е степен на двойката. Какво правим в общия случай? Един лесен начин е да допълним масива до най-близката степен на двойката с нули. Това обаче е напълно излишно. Може да се забележи, че ако използваме същата зависимост за позициите на връх и неговите деца, няма да имаме проблеми. Единствено в последното ниво (това на листата) може да имаме дупки в номерацията, т.е. номера, на които не съответстват връхове. Но ако винаги ползваме рекурсивната дефиниция,  това няма да създава проблеми. За да е по-ясно, вижте номерацията на върховете при сегметното дърво построено за 10 елемента, например. Един важен детайл е за броя върхове, които могат да ни трябват. Ако \(n=2^s+4\), може да се види, че спазвайки номерацията, максималния номер, който ще ни трябва ще е \(2^{s+1}+2^s+2^{s-1}+1=\) \((2n-8)+(n-4)+(n/2-2)+1=\) \(3n+n/2-13>3n\). Както казахме, ако \(n\) не е степен на двойката, последното ниво не е пълно. Ако най-близката \(\ge\) степен  на двойката e \(2^s \le 2n\), то за да направим оценка за максималния брой върхове, можем да мислим, че го построяваме върху масив с \(2^s\) елемента. Такова дърво би имало най-много \(2.2^s-1 \lt 4n\) елемента. Затова обикновено в задачи, когато има максимално ограничение \(MAXN\) за големината на масива с числата, за да няма големи разсъждения сегметното дърво се прави с големина \(4.MAXN\). От сега нататък вече не налагаме ограничение за големината на масива \(n\).</p>
                        <p class="text-format">Нека означим масива за сегментното дърво с \(tree\). Понеже разглеждаме сегментно дърво, което ще отговаря заявки за сума, то в масива за всеки връх ще пазим сумата на числата в масива, за които отговаря (<a class="info" onclick="triggerInfo(2)" id="trigger2">...</a><a class="info" onclick="triggerInfo(2)" id="info2" style="display: none">това са и записаните числа във върховете на дървото на интерактивния пример</a>). При листата, тази стойност отговаря само за едно число. Нека сме на връх с номер \(k\). Съответно лявото дете, което съдържа сумата на числата в лявата половина, ще е с номер \(2k\), а дясното дете, което отговаря за сумата на дясната половина - \(2k+1\). Тогава имаме следната лесна формула, за да сметнем стойността за върха \(k\) - \(tree[k]=tree[2k]+tree[2k+1]\). Това ни дава два лесни начина да построим сегметно дърво. Първият е итеративен - започваме да попълваме върховете в ред обратен на номерацията. По този начин, когато стигнем връх вече ще сме попълнили стойностите на децата му и ще можем по формулата да сметнем стойността му. Вторият начин, който ще покажем, е рекурсивен и следва рекурсивната дефиниция на структурата от данни:</p>
                        <div id="build-tree"></div>
                        <script> $.get("/algo-site/pages/ds_tree_lessons/segment_trees/build-tree.html", function (data) {
                                $("#build-tree").replaceWith(data);
                                });
                        </script>
                    </div>
                </div>

                <div class="lesson-part-position">
                    <button class="btn btn-secondary" onclick="toggleText('thirdPart'); initExamples(3)">3. Обработка на заявки</button>
                    <div id="thirdPart">

                    </div>
                </div>

                <div class="lesson-part-position">
                    <button class="btn btn-secondary" onclick="toggleText('thirdPart'); initExamples(3)">4. Динамични сегментни дървета</button>
                    <div id="fourthPart">

                    </div>
                </div>
            </div>
            
            <div id="footer-placeholder"></div>
        </div>
        
        
    </body>
</html>