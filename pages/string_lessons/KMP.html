<!DOCTYPE html>
<html>
    <head>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-Y8NQ36XMJS"></script>
		<script>
		  window.dataLayer = window.dataLayer || [];
		  function gtag(){dataLayer.push(arguments);}
		  gtag('js', new Date());

		  gtag('config', 'G-Y8NQ36XMJS');
		</script>
        
        <link rel="shortcut icon" href="/algo-site/images/favicon.ico">
        <link type="text/css" rel="stylesheet" href="/algo-site/node_modules/bootstrap/dist/css/bootstrap.min.css"  media="screen,projection"/>
        <link type="text/css" rel="stylesheet" href="/algo-site/styles/style.css"  media="screen,projection"/>
        <link type="text/css" rel="stylesheet" href="/algo-site/styles/lesson.css"  media="screen,projection"/>
        <link type="text/css" rel="stylesheet" href="/algo-site/node_modules/@highlightjs/cdn-assets/styles/github-dark.min.css">
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
        <script type="text/javascript" src="/algo-site/node_modules/jquery/dist/jquery.slim.min.js"></script>
        <script type="text/javascript" src="/algo-site/node_modules/jquery/dist/jquery.min.js"></script>
        <script type="text/javascript" src="/algo-site/node_modules/@popperjs/core/dist/umd/popper.min.js"></script>
        <script type="text/javascript" src="/algo-site/node_modules/bootstrap/dist/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="/algo-site/node_modules/snapsvg/dist/snap.svg-min.js"></script>
        <script id="MathJax-script" async src="/algo-site/node_modules/mathjax/es5/tex-chtml.js"></script>
        <script type="text/javascript" src="/algo-site/node_modules/@highlightjs/cdn-assets/highlight.min.js"></script>
        <script type="text/javascript" src="/algo-site/js/main.js"></script>
        <script type="text/javascript" src="/algo-site/js/animation.js"></script>
        <script type="text/javascript" src="/algo-site/js/string_lessons/KMP.js"></script>
        <title>KMP</title>
    </head>
    <body>
        <header>
            <div id="nav-placeholder"></div>
            <nav aria-label="breadcrumb" class="unselectable">
                <ol class="breadcrumb">
                    <li class="breadcrumb-item">
                        <a href="/algo-site/pages/string_lessons.html" class="link-danger">Низове</a>
                    </li>
                    <li class="breadcrumb-item">
                        <a class="link-secondary">KMP</a>
                    </li>
                    <li class="ms-auto">Последна промяна: 30.12.2022</li>
                </ol>
            </nav>
        </header>
        
        <div class="wrapper" tabindex="-1">
            <div class="content">            
                <h1 align="center">Алгоритъм на Кнут-Морис-Прат</h1>

                <div class="lesson-part-position">
                    <button class="btn btn-secondary">1. Наивен алгоритъм.</button>
                    <div class="lesson-part">
                        <p class="text-format">Проблемът, който решаваме е често срещан - търсене на един низ в друг. Така можем да мислим, че имаме един малък низ, който наричаме шаблон, и стандартно означаваме дължината му с \(m\). Този шаблон търсим дали се среща (или всички срещания) в голям низ, който наричаме текст, а дължината му означаваме с \(n\).</p>
                        <p class="text-format">Има лесен наивен алгоритъм за тази задача, като просто за всяка възможна позиция в текста проверяваме дали там се среща шаблонът. Понеже тази проверка е линейна по шаблона, то общо сложността на алгоритъма е \(O(nm)\). Често срещана грешна оптимизация на наивния алгоритъм е да търсим шаблона не от всяка една възможна позиция в текста, а когато не го намерим, да пробваме от буквата, до която сме стигнали и сме се провалили. Разбира се, лесно се стига до пропуски с този начин. Нека например шаблонът е \(ababac\), а текстът е \(abababac\). Лесно се вижда, че шаблонът се среща на позиция 3 в текста. Но с грешната оптимизация първо ще пробваме за срещане на позиция 1, ще установим, че не се среща чак когато сравним 6-тата буква на текста с тази на шаблона и установим разлика, след което ще пробваме да намерим шаблона на позиция 6 и така ще пропуснаме неговото срещане на позиция 3.</p>
                        <p class="text-format">Всъщност <i>КМР</i> алгоритъмът представлява точно оптимизиация на наивния, но направена правилно и постигаща линейна сложност - \(O(n+m)\). Идеята е да се възползваме от получената информация - това, че вече сме сравнили част от буквите, когато не успеем да намерим шаблона на дадена позиция. Проблемът на грешната оптимизация е, че шаблонът е възможно да се среща и по-рано от първата разлика. Затова можем да изпозваме знанието, че първите пет букви от шаблона и текста съвпадат (разликата е при 6-тата) и така следващата смислена позиция, на която да търсим шаблона е 3, защото 3-тата, 4-тата и 5-тата буква на текста съвпадат с първите три буква на шаблона. Хитрото е, че няма да сравняваме отново тези букви, а директно като търсим шаблона от позиция 3 в текста, ще сравняваме 6-тата буква в текста с 4-тата на шаблона и като продължим ще намерим срещането. Сложната част разбира се е как скачаме на следваща позиция и с този въпрос ще се занимаваме в следващата точка.</p>
                        <p class="text-format">Хубаво е да споменем и алгоритъма на <i>Рабин-Карп</i>, който се занимава със същия проблем. Той е със същата сложност като <i>КМР</i>, но е с по-голяма константа, заради хеширането, а има и друг недостатък. Поради използването на хеширането не е гарантирано, че винаги ще е коректен (или ако го реализираме коректен, няма да е гарантирано, че ще има линейна сложност). Така че <i>КМР</i> алгоритъмът има значително предимство пред <i>Рабин-Карп</i>, а също така се пише и доста кратко, макар да е доста по-сложен за разбиране.</p>
                    </div>
                </div>
                <div class="lesson-part-position">
                    <button class="btn btn-secondary">2. Функция на неуспеха.</button>
                    <div class="lesson-part">
                        <p class="text-format">Както горе беше подсказано, като знаем, че някаква част от шаблона вече се среща в текста и получим разлика, трябва да знаем къде да търсим след това в текста. Тук можем да се възползваме, че еднаквата част е някакъв префикс на шаблона, т.е. нужната информация винаги е за някой префикс на шаблона. Това, което искаме да знаем, е къде трябва да се предвижим като следваща позиция за търсене. Разбира се, от тази позиция нататък трябва отново да имаме съвпадение със шаблона. Ако разгледаме отново предния пример със шаблон \(\underline{ababa}c\) (съвпадащата част с текста е подчертана), то следващата удачна позиция е третата - \(ab\underline{aba}c\). Така, ако почнем от там (на съответното място в текста), знаем, че първите три символа на шаблона ги има. Сега вече можем по-формално да кажем какво търсим: за даден префикс на шаблона търсим най-дългия му суфикс, който се явява префикс на шаблона. Нека означим шаблона със \(s\).</p>
                        <p class="text-format bold">Определение: Един суфикс на префикса \(s[0...i]\), ще наричаме <i>добър</i> за позиция \(i\), ако той е същински суфикс и се явява префикс на \(s\). Тогава функция на неуспеха (още се нарича префиксна) за низа \(s\), ще наричаме \(f\), където \(f(i)=|\)най-дългият <i>добър</i> суфикс за позиция \(i|\).</p>
                        <p class="text-format">Важно е, че гледаме същински суфикси, защото иначе \(f(i)=i+1\) за всяко \(i\). Освен това гледаме и суфикси с нулева дължина, за да имаме винаги поне един <i>добър</i> суфикс. Лесно се вижда, че ако сметнем тази функция вече ще можем при неуспех на търсенето на шаблона да скачаме директно на следващата възможна позиция и да направим грешната оптимизация вярна. Ще се концентрираме върху намирането на функцията \(f\). Можем да подходим с динамично програмиране. За целта нека разпишем функцията на неуспеха за по-интересния шаблон \(s=aabaabaaac\).</p>
                        <div class="table-responsive" style="margin-bottom: 2vh">
                            <table class="table table-hover table-dark table-bordered text-center" style="width: auto; margin: auto">
                                <thead>
                                    <tr>
                                        <td style="background: grey">\(i\)</td>
                                        <td style="background: grey">\(0\)</td>
                                        <td style="background: grey">\(1\)</td>
                                        <td style="background: grey">\(2\)</td>
                                        <td style="background: grey">\(3\)</td>
                                        <td style="background: grey">\(4\)</td>
                                        <td style="background: grey">\(5\)</td>
                                        <td style="background: grey">\(6\)</td>
                                        <td style="background: grey">\(7\)</td>
                                        <td style="background: grey">\(8\)</td>
                                        <td style="background: grey">\(9\)</td>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td style="background: grey">\(s\)</td>
                                        <td class="align-middle">\(a\)</td>
                                        <td class="align-middle">\(a\)</td>
                                        <td class="align-middle">\(b\)</td>
                                        <td class="align-middle">\(a\)</td>
                                        <td class="align-middle">\(a\)</td>
                                        <td class="align-middle">\(b\)</td>
                                        <td class="align-middle">\(a\)</td>
                                        <td class="align-middle">\(a\)</td>
                                        <td class="align-middle">\(a\)</td>
                                        <td class="align-middle">\(c\)</td>
                                    </tr>
                                    <tr>
                                        <td style="background: grey">\(f\)</td>
                                        <td class="align-middle">\(0\)</td>
                                        <td class="align-middle">\(1\)</td>
                                        <td class="align-middle">\(0\)</td>
                                        <td class="align-middle">\(1\)</td>
                                        <td class="align-middle">\(2\)</td>
                                        <td class="align-middle">\(3\)</td>
                                        <td class="align-middle">\(4\)</td>
                                        <td class="align-middle">\(5\)</td>
                                        <td class="align-middle">\(2\)</td>
                                        <td class="align-middle">\(0\)</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="text-format">Забелязваме, че стойностите нарастват най-много с 1. Това лесно се вижда. Ако допуснем, че за някоя позиция \(i+1\): \(f(i+1)=f(i)+k\), където \(k>1\), то ако махнем последния символ на максималния <i>добър</i> суфикс за позиция \(i+1\), ще получим суфикс на \(s[0...i]\), който се явява и префикс на \(s\) с дължина \(f(i+1)-1=\) \(f(i)+k-1>f(i)\) при \(k>1\). Така получаваме по-дълъг <i>добър</i> суфикс за позиция \(i\) и стигаме до противоречие с намерената стойност за \(f(i)\). Освен това много лесно можем да разберем дали сме в този случай. Нека сме намерили стойностите \(f(0), f(1), ..., f(i)\) и трябва да намерим \(f(i+1)\). Нека означим \(f(i)=l\). Имаме 2 случая. Първият, по-лесен случай, е ако \(s[l]=s[i+1]\). Тогава можем да удължим намерения най-дълъг <i>добър</i> суфикс за позиция \(i\) с текущия символ на низа (<a class="info">...</a><a class="info" style="display: none">символът \(s[i+1]\)</a>) и да получим <i>добър</i> суфикс за позиция \(i+1\) (равенството на символите позволява след удължаването на суфикса с текущия символ, той да остане префикс на \(s\)). За по-добро разбиране можем да разгледаме \(f(5)\). Имаме, че \(f(4)=2\) или: \(\colorbox{lightblue}{$aa$}b\colorbox{lightblue}{$aa$}b...\) Понеже \(s[l]=s[2]=b\) и \(s[5]=b\), то като удължим <i>добрия</i> суфикс \(aa\) за позиция 4 с \(b=s[5]\), получаваме добър суфикс за позиция 5 - \(\colorbox{lightblue}{$aab$}\textcolor{blue}{aab}...\) Съответно, това е най-дългият <i>добър</i> суфикс за позиция 5 (<a class="info">...</a><a class="info" style="display: none">\(f(5)=3\)</a>), защото от наблюдението по-рано, ако има по-дълъг, то щяхме да получим по-дълъг и за \(f(4)\). Така за лесния случай получаваме, че просто \(f(i+1)=f(i)+1\) - случая, когато дължината нараства с 1.</p>
                        <p class="text-format">Сега ще разгледаме трудния случай, когато \(s[l] \neq s[i+1]\) и не можем просто да удължим стария най-дълъг <i>добър</i> суфикс, за да получим новия. Тук дължината винаги намалява (<a class="info">...</a><a class="info" style="display: none">може да се докаже, че няма как да остане същата, защото ако остане същата, то ще се получи, че префиксът е съставен от една и съща буква и ще има по-дълъг <i>добър</i> суфикс</a>). Нека погледнем как най-дългият <i>добър</i> суфикс за позиция \(i+1\) се отнася към този за позиция \(i\). Схематично, ако означим със син цвят най-дългия <i>добър</i> суфикс за позиция \(i\), то имаме следната ситуация: \(\colorbox{lightblue}{$s_0 \space s_1 \space ... \space s_{l-1}$}s_l\) \(...\space s_{i-l} \colorbox{lightblue}{$s_{i-l+1} \space ... \space s_i$}s_{i+1} \space ...\), където съответният префикс, който трябва да съвпада с <i>добрия</i> суфикс, също е оцветен в синьо. (<a class="info">...</a><a class="info" style="display: none">разбира се, схемата не е много точна, защото може двете еднакви сини области да се пресичат</a>) Нека \(f(i+1)=t\), където \(t \lt l\) и означим схематично с оранжев цвят, най-дългия <i>добър</i> суфикс за позиция \(i+1\). Тогава имаме следната ситуация: \(\colorbox{lightblue}{$\textcolor{orange}{s_0 \space s_1 \space ... \space s_{t-1}} \space s_t \space ... \space s_{l-1}$}s_l\) \(... \space s_{i-l} \colorbox{lightblue}{$s_{i-l+1} \space ... \space s_{i-t+1} \space \textcolor{orange}{s_{i-t+2} \space ... \space s_i}$}\textcolor{orange}{s_{i+1}} \space ...\) Но от това, че двете сини части съвпадат, се получава, че има още оранжеви области, които са еднакви. Ако премахнем последния символ на най-дългия <i>добър</i> суфикс за позиция \(i+1\) и само това остане оранжево, то ако пренесем оранжевия суфикс на втората синя част като суфикс на първата синя част, получаваме следното: \(\colorbox{lightblue}{$\textcolor{orange}{s_0 \space s_1 \space ... \space s_{t-2}} \space s_{t-1} \space ... \space s_{l-t} \space \textcolor{orange}{s_{l-t+1} \space ... \space s_{l-1}}$}s_l\) \(... \space s_{i-l} \colorbox{lightblue}{$s_{i-l+1} \space ... \space s_{i-t} \space \textcolor{orange}{s_{i-t+1} \space ... \space s_i}$}s_{i+1} \space ...\) (<a class="info">...</a><a class="info" style="display: none">тук отново за простота, разглеждаме че сините области не се пресичат, както и оранжевите</a>). Важното наблюдение, което можем да направим е, че оранжевият низ се явява <i>добър</i> суфикс за позиция \(l-1\) и също е вярно, че \(s[t-1]=s[i+1]\).</p>
                        <p class="text-format">Това, което не знаем, е дали оранжевият низ е най-дългият добър суфикс за \(l-1\). Ако това е така, то \(t-1=f(l-1) \Rightarrow f(i+1)=t=f(l-1)+1\). Лесно можем да разберем дали оранжевия низ е най-дългият <i>добър</i> суфикс или не, като просто разгледаме два случая. Ако \(s[f(l-1)]=s[i+1]\), то от горната схема се вижда, че наистина можем да продължим префикса, съответстващ на най-дългия <i>добър</i> суфикс за позиция \(l-1\), със символа \(s[f(l-1)]\) и така ще получим <i>добър</i> суфикс за текущата позиция - \(i+1\)! А той трябва да е най-дългият иначе ще получим противоречие с някои от предните аргументи. Но пак имаме и втори случай, когато \(s[f(l-1)] \neq s[i+1]\). Обаче сега можем с аналогични разсъждения да видим, че търсеният най-дълъг <i>добър</i> суфикс без последната буква ще e <i>добър</i> суфикс освен на позиция \(l-1=f(i)-1\) и на позиция \(f(l-1)-1\). Всъщност, за да намерим най-дългият <i>добър</i> суфикс трябва да се връщаме по префиксите, съотвестващи на най-дългите <i>добри</i> суфикси, докато не срещнем равенство на съответния символ с текущия \(s[i+1]\) (или ако въобще не срещнем равенство, спираме, когато достигнем до префикс с нулева дължина).</p>
                        <p class="text-format">Ще илюстрираме вече алгоритъма за конкретен случай - при намирането на \(f(8)=2\). Първо, понеже \(s[8] \neq s[f(7)]=s[5]\), то трябва да пробваме евентуално за най-дългият <i>добър</i> суфикс на позиция \(4\). Имаме следната схема: \(\colorbox{lightblue}{$\underline{aa}b\textcolor{blue}{\underline{aa}}$}\)\(\textcolor{blue}{b\underline{aa}}a...\) (вторият син низ тук е просто подчертан за по-прегледно, защото се пресича с първия син, а тук сме подчертали най-дългия <i>добър</i> суфикс за \(s[5]\) и гаратираните му срещания на други места). Тук като проверим, че \(s[f(4)]=s[2] \neq s[8]\) ще се върнем до префикса на позиция \(f(4)-1=1\). Сега имаме следната илюстрация: \(\colorbox{lightblue}{$\underline{a} \space \underline{a}$}\)\(baab\colorbox{lightblue}{$a\underline{a}$}a...\) Вече ще видим, че \(s[f(1)]=s[1]=s[8]\), което означава, че можем да удължим префикса \(a\), който е най-дългият <i>добър</i> суфикс на позиция \(1\), с буквата \(s[f(1)]=a\) и получаваме най-дългия <i>добър</i> суфикс за позиция \(8\).</p>
                        <div class="failureExample row" style="clear: both">
                            <div class="col-sm">
                                <p class="text-format">За по-добро разбиране е предоставен интерактивен пример, където за даден шаблон \(s\) се намира функцията на неуспеха. Освен това може да се проиграе намирането на дадена стойност на \(f\) по начина, по който по-горе разсъждавахме.</p>
                                <div class="row mb-2">
                                    <div class="col-auto">
                                        <button class="btn btn-primary default">Начален пример</button>
                                    </div>
                                </div>
                                <div class="row">
                                    <div class="col-auto">
                                        <div class="row form-group mb-2">
                                            <label for="model" class="col-auto col-form-label pe-0 unselectable">\(s\):</label>
                                            <div class="col-auto">
                                                <input class="form-control model" maxLength="20" style="width: 15rem; max-width: 100%"/>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="col-auto">
                                        <button class="btn btn-primary calc-f">Намери \(f\)</button>
                                    </div>
                                </div>
                            </div>
                            <div class="col-sm right-col">
                                <div class="table-responsive mb-2">
                                    <table class="table table-hover table-dark table-bordered w-auto my-auto" id="failureTable"></table>
                                </div>
                                <div class="row mb-2 animation-panel"></div>
                                <p class="anim-func mb-0" style="text-align: justify"></p>
                                <p class="anim-text"></p>
                            </div>
                        </div>
                        <p class="text-format">Последно показваме реализация на функция, която намира стойностите на функцията на неуспеха по описания алгоритъм. Както се вижда, кодът е доста кратък и елегантен.</p>
                        <div id="failure-function" class="placeholder"></div>
                    </div>
                </div>

                <div class="lesson-part-position">
                    <button class="btn btn-secondary">3. Същински алгоритъм.</button>
                    <div class="lesson-part">
                        
                    </div>
                </div>
                
                <div class="lesson-part-position">
                    <button class="btn btn-secondary">4. Анализ на сложността.</button>
                    <div class="lesson-part">
                        
                    </div>
                </div>
                
                <hr>
                <div class="lesson-part-position">
                    <button class="btn btn-secondary">Задачи</button>
                </div>
            </div>
            
            <div id="footer-placeholder"></div>
        </div>
    </body>
</html>